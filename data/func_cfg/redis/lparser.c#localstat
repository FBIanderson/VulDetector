static void localstat(LexState *ls)
 [B9 (ENTRY)]
   Succs (1): B8

 [B1]
   1: DeclRefExpr 0x558fa8f3d380 <lparser.c:1193:3> 'void (LexState *, int, int, expdesc *)' Function 0x558fa8efeab0 'adjust_assign' 'void (LexState *, int, int, expdesc *)'
adjust_assign
   2: ImplicitCastExpr 0x558fa8f3d468 <lparser.c:1193:3> 'void (*)(LexState *, int, int, expdesc *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f3d380 <col:3> 'void (LexState *, int, int, expdesc *)' Function 0x558fa8efeab0 'adjust_assign' 'void (LexState *, int, int, expdesc *)'
[B1.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *, int, int, expdesc *))
   3: DeclRefExpr 0x558fa8f3d3a8 <lparser.c:1193:17> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f3d4c8 <lparser.c:1193:17> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3d3a8 <col:17> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
[B1.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: DeclRefExpr 0x558fa8f3d3d0 <lparser.c:1193:21> 'int' lvalue Var 0x558fa8f3cb60 'nvars' 'int'
nvars
   6: ImplicitCastExpr 0x558fa8f3d4e0 <lparser.c:1193:21> 'int' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3d3d0 <col:21> 'int' lvalue Var 0x558fa8f3cb60 'nvars' 'int'
[B1.5] (ImplicitCastExpr, LValueToRValue, int)
   7: DeclRefExpr 0x558fa8f3d3f8 <lparser.c:1193:28> 'int' lvalue Var 0x558fa8f3cc10 'nexps' 'int'
nexps
   8: ImplicitCastExpr 0x558fa8f3d4f8 <lparser.c:1193:28> 'int' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3d3f8 <col:28> 'int' lvalue Var 0x558fa8f3cc10 'nexps' 'int'
[B1.7] (ImplicitCastExpr, LValueToRValue, int)
   9: DeclRefExpr 0x558fa8f3d420 <lparser.c:1193:36> 'expdesc':'struct expdesc' lvalue Var 0x558fa8f3cc98 'e' 'expdesc':'struct expdesc'
e
  10: UnaryOperator 0x558fa8f3d448 <lparser.c:1193:35, col:36> 'expdesc *' prefix '&'
`-DeclRefExpr 0x558fa8f3d420 <col:36> 'expdesc':'struct expdesc' lvalue Var 0x558fa8f3cc98 'e' 'expdesc':'struct expdesc'
&[B1.9]
  11: CallExpr 0x558fa8f3d480 <lparser.c:1193:3, col:37> 'void'
|-ImplicitCastExpr 0x558fa8f3d468 <col:3> 'void (*)(LexState *, int, int, expdesc *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f3d380 <col:3> 'void (LexState *, int, int, expdesc *)' Function 0x558fa8efeab0 'adjust_assign' 'void (LexState *, int, int, expdesc *)'
|-ImplicitCastExpr 0x558fa8f3d4c8 <col:17> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f3d3a8 <col:17> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
|-ImplicitCastExpr 0x558fa8f3d4e0 <col:21> 'int' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f3d3d0 <col:21> 'int' lvalue Var 0x558fa8f3cb60 'nvars' 'int'
|-ImplicitCastExpr 0x558fa8f3d4f8 <col:28> 'int' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f3d3f8 <col:28> 'int' lvalue Var 0x558fa8f3cc10 'nexps' 'int'
`-UnaryOperator 0x558fa8f3d448 <col:35, col:36> 'expdesc *' prefix '&'
  `-DeclRefExpr 0x558fa8f3d420 <col:36> 'expdesc':'struct expdesc' lvalue Var 0x558fa8f3cc98 'e' 'expdesc':'struct expdesc'
[B1.2]([B1.4], [B1.6], [B1.8], [B1.10])
  12: DeclRefExpr 0x558fa8f3d510 <lparser.c:1194:3> 'void (LexState *, int)' Function 0x558fa8ef6740 'adjustlocalvars' 'void (LexState *, int)'
adjustlocalvars
  13: ImplicitCastExpr 0x558fa8f3d588 <lparser.c:1194:3> 'void (*)(LexState *, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f3d510 <col:3> 'void (LexState *, int)' Function 0x558fa8ef6740 'adjustlocalvars' 'void (LexState *, int)'
[B1.12] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *, int))
  14: DeclRefExpr 0x558fa8f3d538 <lparser.c:1194:19> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
ls
  15: ImplicitCastExpr 0x558fa8f3d5d8 <lparser.c:1194:19> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3d538 <col:19> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
[B1.14] (ImplicitCastExpr, LValueToRValue, LexState *)
  16: DeclRefExpr 0x558fa8f3d560 <lparser.c:1194:23> 'int' lvalue Var 0x558fa8f3cb60 'nvars' 'int'
nvars
  17: ImplicitCastExpr 0x558fa8f3d5f0 <lparser.c:1194:23> 'int' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3d560 <col:23> 'int' lvalue Var 0x558fa8f3cb60 'nvars' 'int'
[B1.16] (ImplicitCastExpr, LValueToRValue, int)
  18: CallExpr 0x558fa8f3d5a0 <lparser.c:1194:3, col:28> 'void'
|-ImplicitCastExpr 0x558fa8f3d588 <col:3> 'void (*)(LexState *, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f3d510 <col:3> 'void (LexState *, int)' Function 0x558fa8ef6740 'adjustlocalvars' 'void (LexState *, int)'
|-ImplicitCastExpr 0x558fa8f3d5d8 <col:19> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f3d538 <col:19> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
`-ImplicitCastExpr 0x558fa8f3d5f0 <col:23> 'int' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f3d560 <col:23> 'int' lvalue Var 0x558fa8f3cb60 'nvars' 'int'
[B1.13]([B1.15], [B1.17])
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: DeclRefExpr 0x558fa8f3d250 <lparser.c:1190:11> 'int' EnumConstant 0x558fa8eb0890 'VVOID' 'int'
VVOID
   2: ImplicitCastExpr 0x558fa8f3d278 <lparser.c:1190:11> 'expkind':'expkind' <IntegralCast>
`-DeclRefExpr 0x558fa8f3d250 <col:11> 'int' EnumConstant 0x558fa8eb0890 'VVOID' 'int'
[B2.1] (ImplicitCastExpr, IntegralCast, expkind)
   3: DeclRefExpr 0x558fa8f3d1f0 <lparser.c:1190:5> 'expdesc':'struct expdesc' lvalue Var 0x558fa8f3cc98 'e' 'expdesc':'struct expdesc'
e
   4: MemberExpr 0x558fa8f3d218 <lparser.c:1190:5, col:7> 'expkind':'expkind' lvalue .k 0x558fa8eb0e70
`-DeclRefExpr 0x558fa8f3d1f0 <col:5> 'expdesc':'struct expdesc' lvalue Var 0x558fa8f3cc98 'e' 'expdesc':'struct expdesc'
[B2.3].k
   5: BinaryOperator 0x558fa8f3d290 <lparser.c:1190:5, col:11> 'expkind':'expkind' '='
|-MemberExpr 0x558fa8f3d218 <col:5, col:7> 'expkind':'expkind' lvalue .k 0x558fa8eb0e70
| `-DeclRefExpr 0x558fa8f3d1f0 <col:5> 'expdesc':'struct expdesc' lvalue Var 0x558fa8f3cc98 'e' 'expdesc':'struct expdesc'
`-ImplicitCastExpr 0x558fa8f3d278 <col:11> 'expkind':'expkind' <IntegralCast>
  `-DeclRefExpr 0x558fa8f3d250 <col:11> 'int' EnumConstant 0x558fa8eb0890 'VVOID' 'int'
[B2.4] = [B2.2]
   6: IntegerLiteral 0x558fa8f3d2e0 <lparser.c:1191:13> 'int' 0
0
   7: DeclRefExpr 0x558fa8f3d2b8 <lparser.c:1191:5> 'int' lvalue Var 0x558fa8f3cc10 'nexps' 'int'
nexps
   8: BinaryOperator 0x558fa8f3d300 <lparser.c:1191:5, col:13> 'int' '='
|-DeclRefExpr 0x558fa8f3d2b8 <col:5> 'int' lvalue Var 0x558fa8f3cc10 'nexps' 'int'
`-IntegerLiteral 0x558fa8f3d2e0 <col:13> 'int' 0
[B2.7] = [B2.6]
   Preds (1): B4
   Succs (1): B1

 [B3]
   1: DeclRefExpr 0x558fa8f3d0c8 <lparser.c:1188:13> 'int (LexState *, expdesc *)' Function 0x558fa8f1e988 'explist1' 'int (LexState *, expdesc *)'
explist1
   2: ImplicitCastExpr 0x558fa8f3d160 <lparser.c:1188:13> 'int (*)(LexState *, expdesc *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f3d0c8 <col:13> 'int (LexState *, expdesc *)' Function 0x558fa8f1e988 'explist1' 'int (LexState *, expdesc *)'
[B3.1] (ImplicitCastExpr, FunctionToPointerDecay, int (*)(LexState *, expdesc *))
   3: DeclRefExpr 0x558fa8f3d0f0 <lparser.c:1188:22> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f3d1b0 <lparser.c:1188:22> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3d0f0 <col:22> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
[B3.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: DeclRefExpr 0x558fa8f3d118 <lparser.c:1188:27> 'expdesc':'struct expdesc' lvalue Var 0x558fa8f3cc98 'e' 'expdesc':'struct expdesc'
e
   6: UnaryOperator 0x558fa8f3d140 <lparser.c:1188:26, col:27> 'expdesc *' prefix '&'
`-DeclRefExpr 0x558fa8f3d118 <col:27> 'expdesc':'struct expdesc' lvalue Var 0x558fa8f3cc98 'e' 'expdesc':'struct expdesc'
&[B3.5]
   7: CallExpr 0x558fa8f3d178 <lparser.c:1188:13, col:28> 'int'
|-ImplicitCastExpr 0x558fa8f3d160 <col:13> 'int (*)(LexState *, expdesc *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f3d0c8 <col:13> 'int (LexState *, expdesc *)' Function 0x558fa8f1e988 'explist1' 'int (LexState *, expdesc *)'
|-ImplicitCastExpr 0x558fa8f3d1b0 <col:22> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f3d0f0 <col:22> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
`-UnaryOperator 0x558fa8f3d140 <col:26, col:27> 'expdesc *' prefix '&'
  `-DeclRefExpr 0x558fa8f3d118 <col:27> 'expdesc':'struct expdesc' lvalue Var 0x558fa8f3cc98 'e' 'expdesc':'struct expdesc'
[B3.2]([B3.4], [B3.6])
   8: DeclRefExpr 0x558fa8f3d0a0 <lparser.c:1188:5> 'int' lvalue Var 0x558fa8f3cc10 'nexps' 'int'
nexps
   9: BinaryOperator 0x558fa8f3d1c8 <lparser.c:1188:5, col:28> 'int' '='
|-DeclRefExpr 0x558fa8f3d0a0 <col:5> 'int' lvalue Var 0x558fa8f3cc10 'nexps' 'int'
`-CallExpr 0x558fa8f3d178 <col:13, col:28> 'int'
  |-ImplicitCastExpr 0x558fa8f3d160 <col:13> 'int (*)(LexState *, expdesc *)' <FunctionToPointerDecay>
  | `-DeclRefExpr 0x558fa8f3d0c8 <col:13> 'int (LexState *, expdesc *)' Function 0x558fa8f1e988 'explist1' 'int (LexState *, expdesc *)'
  |-ImplicitCastExpr 0x558fa8f3d1b0 <col:22> 'LexState *' <LValueToRValue>
  | `-DeclRefExpr 0x558fa8f3d0f0 <col:22> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
  `-UnaryOperator 0x558fa8f3d140 <col:26, col:27> 'expdesc *' prefix '&'
    `-DeclRefExpr 0x558fa8f3d118 <col:27> 'expdesc':'struct expdesc' lvalue Var 0x558fa8f3cc98 'e' 'expdesc':'struct expdesc'
[B3.8] = [B3.7]
   Preds (1): B4
   Succs (1): B1

 [B4]
   1: DeclRefExpr 0x558fa8f3cfd0 <lparser.c:1187:7> 'int (LexState *, int)' Function 0x558fa8eed328 'testnext' 'int (LexState *, int)'
testnext
   2: ImplicitCastExpr 0x558fa8f3d038 <lparser.c:1187:7> 'int (*)(LexState *, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f3cfd0 <col:7> 'int (LexState *, int)' Function 0x558fa8eed328 'testnext' 'int (LexState *, int)'
[B4.1] (ImplicitCastExpr, FunctionToPointerDecay, int (*)(LexState *, int))
   3: DeclRefExpr 0x558fa8f3cff8 <lparser.c:1187:16> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f3d088 <lparser.c:1187:16> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3cff8 <col:16> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
[B4.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: CharacterLiteral 0x558fa8f3d020 <lparser.c:1187:20> 'int' 61
'='
   6: CallExpr 0x558fa8f3d050 <lparser.c:1187:7, col:23> 'int'
|-ImplicitCastExpr 0x558fa8f3d038 <col:7> 'int (*)(LexState *, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f3cfd0 <col:7> 'int (LexState *, int)' Function 0x558fa8eed328 'testnext' 'int (LexState *, int)'
|-ImplicitCastExpr 0x558fa8f3d088 <col:16> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f3cff8 <col:16> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
`-CharacterLiteral 0x558fa8f3d020 <col:20> 'int' 61
[B4.2]([B4.4], [B4.5])
   T: if [B4.6]
   Preds (1): B5
   Succs (2): B3 B2

 [B5]
   1: DeclRefExpr 0x558fa8f3cee0 <lparser.c:1186:12> 'int (LexState *, int)' Function 0x558fa8eed328 'testnext' 'int (LexState *, int)'
testnext
   2: ImplicitCastExpr 0x558fa8f3cf48 <lparser.c:1186:12> 'int (*)(LexState *, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f3cee0 <col:12> 'int (LexState *, int)' Function 0x558fa8eed328 'testnext' 'int (LexState *, int)'
[B5.1] (ImplicitCastExpr, FunctionToPointerDecay, int (*)(LexState *, int))
   3: DeclRefExpr 0x558fa8f3cf08 <lparser.c:1186:21> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f3cf98 <lparser.c:1186:21> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3cf08 <col:21> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
[B5.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: CharacterLiteral 0x558fa8f3cf30 <lparser.c:1186:25> 'int' 44
','
   6: CallExpr 0x558fa8f3cf60 <lparser.c:1186:12, col:28> 'int'
|-ImplicitCastExpr 0x558fa8f3cf48 <col:12> 'int (*)(LexState *, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f3cee0 <col:12> 'int (LexState *, int)' Function 0x558fa8eed328 'testnext' 'int (LexState *, int)'
|-ImplicitCastExpr 0x558fa8f3cf98 <col:21> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f3cf08 <col:21> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
`-CharacterLiteral 0x558fa8f3cf30 <col:25> 'int' 44
[B5.2]([B5.4], [B5.5])
   T: do ... while [B5.6]
   Preds (1): B6
   Succs (2): B7 B4

 [B6]
   1: DeclRefExpr 0x558fa8f3cd10 <lparser.c:1185:5> 'void (LexState *, TString *, int)' Function 0x558fa8ef3060 'new_localvar' 'void (LexState *, TString *, int)'
new_localvar
   2: ImplicitCastExpr 0x558fa8f3ce58 <lparser.c:1185:5> 'void (*)(LexState *, TString *, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f3cd10 <col:5> 'void (LexState *, TString *, int)' Function 0x558fa8ef3060 'new_localvar' 'void (LexState *, TString *, int)'
[B6.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *, TString *, int))
   3: DeclRefExpr 0x558fa8f3cd38 <lparser.c:1185:18> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f3ceb0 <lparser.c:1185:18> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3cd38 <col:18> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
[B6.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: DeclRefExpr 0x558fa8f3cd60 <lparser.c:1185:22> 'TString *(LexState *)' Function 0x558fa8eef280 'str_checkname' 'TString *(LexState *)'
str_checkname
   6: ImplicitCastExpr 0x558fa8f3cdb0 <lparser.c:1185:22> 'TString *(*)(LexState *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f3cd60 <col:22> 'TString *(LexState *)' Function 0x558fa8eef280 'str_checkname' 'TString *(LexState *)'
[B6.5] (ImplicitCastExpr, FunctionToPointerDecay, TString *(*)(LexState *))
   7: DeclRefExpr 0x558fa8f3cd88 <lparser.c:1185:36> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
ls
   8: ImplicitCastExpr 0x558fa8f3cdf8 <lparser.c:1185:36> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3cd88 <col:36> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
[B6.7] (ImplicitCastExpr, LValueToRValue, LexState *)
   9: CallExpr 0x558fa8f3cdc8 <lparser.c:1185:22, col:38> 'TString *'
|-ImplicitCastExpr 0x558fa8f3cdb0 <col:22> 'TString *(*)(LexState *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f3cd60 <col:22> 'TString *(LexState *)' Function 0x558fa8eef280 'str_checkname' 'TString *(LexState *)'
`-ImplicitCastExpr 0x558fa8f3cdf8 <col:36> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f3cd88 <col:36> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
[B6.6]([B6.8])
  10: DeclRefExpr 0x558fa8f3ce10 <lparser.c:1185:41> 'int' lvalue Var 0x558fa8f3cb60 'nvars' 'int'
nvars
  11: UnaryOperator 0x558fa8f3ce38 <lparser.c:1185:41, col:46> 'int' postfix '++'
`-DeclRefExpr 0x558fa8f3ce10 <col:41> 'int' lvalue Var 0x558fa8f3cb60 'nvars' 'int'
[B6.10]++
  12: CallExpr 0x558fa8f3ce70 <lparser.c:1185:5, col:48> 'void'
|-ImplicitCastExpr 0x558fa8f3ce58 <col:5> 'void (*)(LexState *, TString *, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f3cd10 <col:5> 'void (LexState *, TString *, int)' Function 0x558fa8ef3060 'new_localvar' 'void (LexState *, TString *, int)'
|-ImplicitCastExpr 0x558fa8f3ceb0 <col:18> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f3cd38 <col:18> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
|-CallExpr 0x558fa8f3cdc8 <col:22, col:38> 'TString *'
| |-ImplicitCastExpr 0x558fa8f3cdb0 <col:22> 'TString *(*)(LexState *)' <FunctionToPointerDecay>
| | `-DeclRefExpr 0x558fa8f3cd60 <col:22> 'TString *(LexState *)' Function 0x558fa8eef280 'str_checkname' 'TString *(LexState *)'
| `-ImplicitCastExpr 0x558fa8f3cdf8 <col:36> 'LexState *' <LValueToRValue>
|   `-DeclRefExpr 0x558fa8f3cd88 <col:36> 'LexState *' lvalue ParmVar 0x558fa8f3ca18 'ls' 'LexState *'
`-UnaryOperator 0x558fa8f3ce38 <col:41, col:46> 'int' postfix '++'
  `-DeclRefExpr 0x558fa8f3ce10 <col:41> 'int' lvalue Var 0x558fa8f3cb60 'nvars' 'int'
[B6.2]([B6.4], [B6.9], [B6.11])
   Preds (2): B7 B8
   Succs (1): B5

 [B7]
   Preds (1): B5
   Succs (1): B6

 [B8]
   1: IntegerLiteral 0x558fa8f3cbc0 <lparser.c:1181:15> 'int' 0
0
   2: DeclStmt 0x558fa8f3cbe0 <lparser.c:1181:3, col:16>col:7
`-VarDecl 0x558fa8f3cb60 <col:3, col:15> col:7 used nvars 'int' cinit
  `-IntegerLiteral 0x558fa8f3cbc0 <col:15> 'int' 0
int nvars = 0;
   3: DeclStmt 0x558fa8f3cc70 <lparser.c:1182:3, col:12>col:7
`-VarDecl 0x558fa8f3cc10 <col:3, col:7> col:7 used nexps 'int'
int nexps;
   4: DeclStmt 0x558fa8f3ccf8 <lparser.c:1183:3, col:12>col:11
`-VarDecl 0x558fa8f3cc98 <col:3, col:11> col:11 used e 'expdesc':'struct expdesc'
expdesc e;
   Preds (1): B9
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1
