static int funcname(LexState *ls, expdesc *v)
 [B8 (ENTRY)]
   Succs (1): B7

 [B1]
   1: DeclRefExpr 0x558fa8f3dea8 <lparser.c:1208:10> 'int' lvalue Var 0x558fa8f3d830 'needself' 'int'
needself
   2: ImplicitCastExpr 0x558fa8f3ded0 <lparser.c:1208:10> 'int' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3dea8 <col:10> 'int' lvalue Var 0x558fa8f3d830 'needself' 'int'
[B1.1] (ImplicitCastExpr, LValueToRValue, int)
   3: ReturnStmt 0x558fa8f3dee8 <lparser.c:1208:3, col:10>
`-ImplicitCastExpr 0x558fa8f3ded0 <col:10> 'int' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f3dea8 <col:10> 'int' lvalue Var 0x558fa8f3d830 'needself' 'int'
return [B1.2];
   Preds (2): B2 B3
   Succs (1): B0

 [B2]
   1: IntegerLiteral 0x558fa8f3dd10 <lparser.c:1205:16> 'int' 1
1
   2: DeclRefExpr 0x558fa8f3dce8 <lparser.c:1205:5> 'int' lvalue Var 0x558fa8f3d830 'needself' 'int'
needself
   3: BinaryOperator 0x558fa8f3dd30 <lparser.c:1205:5, col:16> 'int' '='
|-DeclRefExpr 0x558fa8f3dce8 <col:5> 'int' lvalue Var 0x558fa8f3d830 'needself' 'int'
`-IntegerLiteral 0x558fa8f3dd10 <col:16> 'int' 1
[B2.2] = [B2.1]
   4: DeclRefExpr 0x558fa8f3dd58 <lparser.c:1206:5> 'void (LexState *, expdesc *)' Function 0x558fa8f12ba0 'field' 'void (LexState *, expdesc *)'
field
   5: ImplicitCastExpr 0x558fa8f3ddd0 <lparser.c:1206:5> 'void (*)(LexState *, expdesc *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f3dd58 <col:5> 'void (LexState *, expdesc *)' Function 0x558fa8f12ba0 'field' 'void (LexState *, expdesc *)'
[B2.4] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *, expdesc *))
   6: DeclRefExpr 0x558fa8f3dd80 <lparser.c:1206:11> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
ls
   7: ImplicitCastExpr 0x558fa8f3de20 <lparser.c:1206:11> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3dd80 <col:11> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
[B2.6] (ImplicitCastExpr, LValueToRValue, LexState *)
   8: DeclRefExpr 0x558fa8f3dda8 <lparser.c:1206:15> 'expdesc *' lvalue ParmVar 0x558fa8f3d6d0 'v' 'expdesc *'
v
   9: ImplicitCastExpr 0x558fa8f3de38 <lparser.c:1206:15> 'expdesc *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3dda8 <col:15> 'expdesc *' lvalue ParmVar 0x558fa8f3d6d0 'v' 'expdesc *'
[B2.8] (ImplicitCastExpr, LValueToRValue, expdesc *)
  10: CallExpr 0x558fa8f3dde8 <lparser.c:1206:5, col:16> 'void'
|-ImplicitCastExpr 0x558fa8f3ddd0 <col:5> 'void (*)(LexState *, expdesc *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f3dd58 <col:5> 'void (LexState *, expdesc *)' Function 0x558fa8f12ba0 'field' 'void (LexState *, expdesc *)'
|-ImplicitCastExpr 0x558fa8f3de20 <col:11> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f3dd80 <col:11> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
`-ImplicitCastExpr 0x558fa8f3de38 <col:15> 'expdesc *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f3dda8 <col:15> 'expdesc *' lvalue ParmVar 0x558fa8f3d6d0 'v' 'expdesc *'
[B2.5]([B2.7], [B2.9])
   Preds (1): B3
   Succs (1): B1

 [B3]
   1: DeclRefExpr 0x558fa8f3dbe0 <lparser.c:1204:7> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
ls
   2: ImplicitCastExpr 0x558fa8f3dc08 <lparser.c:1204:7> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3dbe0 <col:7> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
[B3.1] (ImplicitCastExpr, LValueToRValue, LexState *)
   3: MemberExpr 0x558fa8f3dc20 <lparser.c:1204:7, col:11> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
`-ImplicitCastExpr 0x558fa8f3dc08 <col:7> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f3dbe0 <col:7> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
[B3.2]->t
   4: MemberExpr 0x558fa8f3dc58 <lparser.c:1204:7, col:13> 'int' lvalue .token 0x558fa8e9ec88
`-MemberExpr 0x558fa8f3dc20 <col:7, col:11> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
  `-ImplicitCastExpr 0x558fa8f3dc08 <col:7> 'LexState *' <LValueToRValue>
    `-DeclRefExpr 0x558fa8f3dbe0 <col:7> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
[B3.3].token
   5: ImplicitCastExpr 0x558fa8f3dca8 <lparser.c:1204:7, col:13> 'int' <LValueToRValue>
`-MemberExpr 0x558fa8f3dc58 <col:7, col:13> 'int' lvalue .token 0x558fa8e9ec88
  `-MemberExpr 0x558fa8f3dc20 <col:7, col:11> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
    `-ImplicitCastExpr 0x558fa8f3dc08 <col:7> 'LexState *' <LValueToRValue>
      `-DeclRefExpr 0x558fa8f3dbe0 <col:7> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
[B3.4] (ImplicitCastExpr, LValueToRValue, int)
   6: CharacterLiteral 0x558fa8f3dc90 <lparser.c:1204:22> 'int' 58
':'
   7: BinaryOperator 0x558fa8f3dcc0 <lparser.c:1204:7, col:22> 'int' '=='
|-ImplicitCastExpr 0x558fa8f3dca8 <col:7, col:13> 'int' <LValueToRValue>
| `-MemberExpr 0x558fa8f3dc58 <col:7, col:13> 'int' lvalue .token 0x558fa8e9ec88
|   `-MemberExpr 0x558fa8f3dc20 <col:7, col:11> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
|     `-ImplicitCastExpr 0x558fa8f3dc08 <col:7> 'LexState *' <LValueToRValue>
|       `-DeclRefExpr 0x558fa8f3dbe0 <col:7> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
`-CharacterLiteral 0x558fa8f3dc90 <col:22> 'int' 58
[B3.5] == [B3.6]
   T: if [B3.7]
   Preds (1): B6
   Succs (2): B2 B1

 [B4]
   Preds (1): B5
   Succs (1): B6

 [B5]
   1: DeclRefExpr 0x558fa8f3dac8 <lparser.c:1203:5> 'void (LexState *, expdesc *)' Function 0x558fa8f12ba0 'field' 'void (LexState *, expdesc *)'
field
   2: ImplicitCastExpr 0x558fa8f3db40 <lparser.c:1203:5> 'void (*)(LexState *, expdesc *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f3dac8 <col:5> 'void (LexState *, expdesc *)' Function 0x558fa8f12ba0 'field' 'void (LexState *, expdesc *)'
[B5.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *, expdesc *))
   3: DeclRefExpr 0x558fa8f3daf0 <lparser.c:1203:11> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f3db90 <lparser.c:1203:11> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3daf0 <col:11> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
[B5.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: DeclRefExpr 0x558fa8f3db18 <lparser.c:1203:15> 'expdesc *' lvalue ParmVar 0x558fa8f3d6d0 'v' 'expdesc *'
v
   6: ImplicitCastExpr 0x558fa8f3dba8 <lparser.c:1203:15> 'expdesc *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3db18 <col:15> 'expdesc *' lvalue ParmVar 0x558fa8f3d6d0 'v' 'expdesc *'
[B5.5] (ImplicitCastExpr, LValueToRValue, expdesc *)
   7: CallExpr 0x558fa8f3db58 <lparser.c:1203:5, col:16> 'void'
|-ImplicitCastExpr 0x558fa8f3db40 <col:5> 'void (*)(LexState *, expdesc *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f3dac8 <col:5> 'void (LexState *, expdesc *)' Function 0x558fa8f12ba0 'field' 'void (LexState *, expdesc *)'
|-ImplicitCastExpr 0x558fa8f3db90 <col:11> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f3daf0 <col:11> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
`-ImplicitCastExpr 0x558fa8f3dba8 <col:15> 'expdesc *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f3db18 <col:15> 'expdesc *' lvalue ParmVar 0x558fa8f3d6d0 'v' 'expdesc *'
[B5.2]([B5.4], [B5.6])
   Preds (1): B6
   Succs (1): B4

 [B6]
   1: DeclRefExpr 0x558fa8f3d9c0 <lparser.c:1202:10> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
ls
   2: ImplicitCastExpr 0x558fa8f3d9e8 <lparser.c:1202:10> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3d9c0 <col:10> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
[B6.1] (ImplicitCastExpr, LValueToRValue, LexState *)
   3: MemberExpr 0x558fa8f3da00 <lparser.c:1202:10, col:14> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
`-ImplicitCastExpr 0x558fa8f3d9e8 <col:10> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f3d9c0 <col:10> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
[B6.2]->t
   4: MemberExpr 0x558fa8f3da38 <lparser.c:1202:10, col:16> 'int' lvalue .token 0x558fa8e9ec88
`-MemberExpr 0x558fa8f3da00 <col:10, col:14> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
  `-ImplicitCastExpr 0x558fa8f3d9e8 <col:10> 'LexState *' <LValueToRValue>
    `-DeclRefExpr 0x558fa8f3d9c0 <col:10> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
[B6.3].token
   5: ImplicitCastExpr 0x558fa8f3da88 <lparser.c:1202:10, col:16> 'int' <LValueToRValue>
`-MemberExpr 0x558fa8f3da38 <col:10, col:16> 'int' lvalue .token 0x558fa8e9ec88
  `-MemberExpr 0x558fa8f3da00 <col:10, col:14> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
    `-ImplicitCastExpr 0x558fa8f3d9e8 <col:10> 'LexState *' <LValueToRValue>
      `-DeclRefExpr 0x558fa8f3d9c0 <col:10> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
[B6.4] (ImplicitCastExpr, LValueToRValue, int)
   6: CharacterLiteral 0x558fa8f3da70 <lparser.c:1202:25> 'int' 46
'.'
   7: BinaryOperator 0x558fa8f3daa0 <lparser.c:1202:10, col:25> 'int' '=='
|-ImplicitCastExpr 0x558fa8f3da88 <col:10, col:16> 'int' <LValueToRValue>
| `-MemberExpr 0x558fa8f3da38 <col:10, col:16> 'int' lvalue .token 0x558fa8e9ec88
|   `-MemberExpr 0x558fa8f3da00 <col:10, col:14> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
|     `-ImplicitCastExpr 0x558fa8f3d9e8 <col:10> 'LexState *' <LValueToRValue>
|       `-DeclRefExpr 0x558fa8f3d9c0 <col:10> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
`-CharacterLiteral 0x558fa8f3da70 <col:25> 'int' 46
[B6.5] == [B6.6]
   T: while [B6.7]
   Preds (2): B4 B7
   Succs (2): B5 B3

 [B7]
   1: IntegerLiteral 0x558fa8f3d890 <lparser.c:1200:18> 'int' 0
0
   2: DeclStmt 0x558fa8f3d8b0 <lparser.c:1200:3, col:19>col:7
`-VarDecl 0x558fa8f3d830 <col:3, col:18> col:7 used needself 'int' cinit
  `-IntegerLiteral 0x558fa8f3d890 <col:18> 'int' 0
int needself = 0;
   3: DeclRefExpr 0x558fa8f3d8c8 <lparser.c:1201:3> 'void (LexState *, expdesc *)' Function 0x558fa8efe0d8 'singlevar' 'void (LexState *, expdesc *)'
singlevar
   4: ImplicitCastExpr 0x558fa8f3d940 <lparser.c:1201:3> 'void (*)(LexState *, expdesc *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f3d8c8 <col:3> 'void (LexState *, expdesc *)' Function 0x558fa8efe0d8 'singlevar' 'void (LexState *, expdesc *)'
[B7.3] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *, expdesc *))
   5: DeclRefExpr 0x558fa8f3d8f0 <lparser.c:1201:13> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
ls
   6: ImplicitCastExpr 0x558fa8f3d990 <lparser.c:1201:13> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3d8f0 <col:13> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
[B7.5] (ImplicitCastExpr, LValueToRValue, LexState *)
   7: DeclRefExpr 0x558fa8f3d918 <lparser.c:1201:17> 'expdesc *' lvalue ParmVar 0x558fa8f3d6d0 'v' 'expdesc *'
v
   8: ImplicitCastExpr 0x558fa8f3d9a8 <lparser.c:1201:17> 'expdesc *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f3d918 <col:17> 'expdesc *' lvalue ParmVar 0x558fa8f3d6d0 'v' 'expdesc *'
[B7.7] (ImplicitCastExpr, LValueToRValue, expdesc *)
   9: CallExpr 0x558fa8f3d958 <lparser.c:1201:3, col:18> 'void'
|-ImplicitCastExpr 0x558fa8f3d940 <col:3> 'void (*)(LexState *, expdesc *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f3d8c8 <col:3> 'void (LexState *, expdesc *)' Function 0x558fa8efe0d8 'singlevar' 'void (LexState *, expdesc *)'
|-ImplicitCastExpr 0x558fa8f3d990 <col:13> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f3d8f0 <col:13> 'LexState *' lvalue ParmVar 0x558fa8f3d660 'ls' 'LexState *'
`-ImplicitCastExpr 0x558fa8f3d9a8 <col:17> 'expdesc *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f3d918 <col:17> 'expdesc *' lvalue ParmVar 0x558fa8f3d6d0 'v' 'expdesc *'
[B7.4]([B7.6], [B7.8])
   Preds (1): B8
   Succs (1): B6

 [B0 (EXIT)]
   Preds (1): B1
