static void simpleexp(LexState *ls, expdesc *v)
 [B14 (ENTRY)]
   Succs (1): B2

 [B1]
   1: DeclRefExpr 0x558fa8f25358 <lparser.c:774:3> 'void (LexState *)' Function 0x558fa8ea1430 'luaX_next' 'void (LexState *)'
luaX_next
   2: ImplicitCastExpr 0x558fa8f253a8 <lparser.c:774:3> 'void (*)(LexState *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f25358 <col:3> 'void (LexState *)' Function 0x558fa8ea1430 'luaX_next' 'void (LexState *)'
[B1.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *))
   3: DeclRefExpr 0x558fa8f25380 <lparser.c:774:13> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f253f0 <lparser.c:774:13> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f25380 <col:13> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B1.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: CallExpr 0x558fa8f253c0 <lparser.c:774:3, col:15> 'void'
|-ImplicitCastExpr 0x558fa8f253a8 <col:3> 'void (*)(LexState *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f25358 <col:3> 'void (LexState *)' Function 0x558fa8ea1430 'luaX_next' 'void (LexState *)'
`-ImplicitCastExpr 0x558fa8f253f0 <col:13> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f25380 <col:13> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B1.2]([B1.4])
   Preds (6): B6 B9 B10 B11 B12 B13
   Succs (1): B0

 [B2]
   1: DeclRefExpr 0x558fa8f23850 <lparser.c:730:11> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
ls
   2: ImplicitCastExpr 0x558fa8f23878 <lparser.c:730:11> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f23850 <col:11> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B2.1] (ImplicitCastExpr, LValueToRValue, LexState *)
   3: MemberExpr 0x558fa8f23890 <lparser.c:730:11, col:15> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
`-ImplicitCastExpr 0x558fa8f23878 <col:11> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f23850 <col:11> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B2.2]->t
   4: MemberExpr 0x558fa8f238c8 <lparser.c:730:11, col:17> 'int' lvalue .token 0x558fa8e9ec88
`-MemberExpr 0x558fa8f23890 <col:11, col:15> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
  `-ImplicitCastExpr 0x558fa8f23878 <col:11> 'LexState *' <LValueToRValue>
    `-DeclRefExpr 0x558fa8f23850 <col:11> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B2.3].token
   5: ImplicitCastExpr 0x558fa8f23900 <lparser.c:730:11, col:17> 'int' <LValueToRValue>
`-MemberExpr 0x558fa8f238c8 <col:11, col:17> 'int' lvalue .token 0x558fa8e9ec88
  `-MemberExpr 0x558fa8f23890 <col:11, col:15> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
    `-ImplicitCastExpr 0x558fa8f23878 <col:11> 'LexState *' <LValueToRValue>
      `-DeclRefExpr 0x558fa8f23850 <col:11> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B2.4] (ImplicitCastExpr, LValueToRValue, int)
   T: switch [B2.5]
   Preds (1): B14
   Succs (9): B4 B5 B8 B9 B10 B11 B12 B13
     B3

 [B3]
  default:
   1: DeclRefExpr 0x558fa8f251b0 <lparser.c:770:7> 'void (LexState *, expdesc *)' Function 0x558fa8f223d8 'primaryexp' 'void (LexState *, expdesc *)'
primaryexp
   2: ImplicitCastExpr 0x558fa8f25228 <lparser.c:770:7> 'void (*)(LexState *, expdesc *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f251b0 <col:7> 'void (LexState *, expdesc *)' Function 0x558fa8f223d8 'primaryexp' 'void (LexState *, expdesc *)'
[B3.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *, expdesc *))
   3: DeclRefExpr 0x558fa8f251d8 <lparser.c:770:18> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f25278 <lparser.c:770:18> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f251d8 <col:18> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B3.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: DeclRefExpr 0x558fa8f25200 <lparser.c:770:22> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
v
   6: ImplicitCastExpr 0x558fa8f25290 <lparser.c:770:22> 'expdesc *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f25200 <col:22> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
[B3.5] (ImplicitCastExpr, LValueToRValue, expdesc *)
   7: CallExpr 0x558fa8f25240 <lparser.c:770:7, col:23> 'void'
|-ImplicitCastExpr 0x558fa8f25228 <col:7> 'void (*)(LexState *, expdesc *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f251b0 <col:7> 'void (LexState *, expdesc *)' Function 0x558fa8f223d8 'primaryexp' 'void (LexState *, expdesc *)'
|-ImplicitCastExpr 0x558fa8f25278 <col:18> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f251d8 <col:18> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
`-ImplicitCastExpr 0x558fa8f25290 <col:22> 'expdesc *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f25200 <col:22> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
[B3.2]([B3.4], [B3.6])
   8: ReturnStmt 0x558fa8f252a8 <lparser.c:771:7>
return;
   Preds (1): B2
   Succs (1): B0

 [B4]
  case TK_FUNCTION:
   1: DeclRefExpr 0x558fa8f24eb0 <lparser.c:765:7> 'void (LexState *)' Function 0x558fa8ea1430 'luaX_next' 'void (LexState *)'
luaX_next
   2: ImplicitCastExpr 0x558fa8f24f00 <lparser.c:765:7> 'void (*)(LexState *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f24eb0 <col:7> 'void (LexState *)' Function 0x558fa8ea1430 'luaX_next' 'void (LexState *)'
[B4.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *))
   3: DeclRefExpr 0x558fa8f24ed8 <lparser.c:765:17> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f24f48 <lparser.c:765:17> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f24ed8 <col:17> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B4.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: CallExpr 0x558fa8f24f18 <lparser.c:765:7, col:19> 'void'
|-ImplicitCastExpr 0x558fa8f24f00 <col:7> 'void (*)(LexState *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f24eb0 <col:7> 'void (LexState *)' Function 0x558fa8ea1430 'luaX_next' 'void (LexState *)'
`-ImplicitCastExpr 0x558fa8f24f48 <col:17> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f24ed8 <col:17> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B4.2]([B4.4])
   6: DeclRefExpr 0x558fa8f24f60 <lparser.c:766:7> 'void (LexState *, expdesc *, int, int)' Function 0x558fa8f1d710 'body' 'void (LexState *, expdesc *, int, int)'
body
   7: ImplicitCastExpr 0x558fa8f250c8 <lparser.c:766:7> 'void (*)(LexState *, expdesc *, int, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f24f60 <col:7> 'void (LexState *, expdesc *, int, int)' Function 0x558fa8f1d710 'body' 'void (LexState *, expdesc *, int, int)'
[B4.6] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *, expdesc *, int, int))
   8: DeclRefExpr 0x558fa8f24f88 <lparser.c:766:12> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
ls
   9: ImplicitCastExpr 0x558fa8f25128 <lparser.c:766:12> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f24f88 <col:12> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B4.8] (ImplicitCastExpr, LValueToRValue, LexState *)
  10: DeclRefExpr 0x558fa8f24fb0 <lparser.c:766:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
v
  11: ImplicitCastExpr 0x558fa8f25140 <lparser.c:766:16> 'expdesc *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f24fb0 <col:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
[B4.10] (ImplicitCastExpr, LValueToRValue, expdesc *)
  12: IntegerLiteral 0x558fa8f24fd8 <lparser.c:766:19> 'int' 0
0
  13: DeclRefExpr 0x558fa8f24ff8 <lparser.c:766:22> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
ls
  14: ImplicitCastExpr 0x558fa8f25020 <lparser.c:766:22> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f24ff8 <col:22> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B4.13] (ImplicitCastExpr, LValueToRValue, LexState *)
  15: MemberExpr 0x558fa8f25038 <lparser.c:766:22, col:26> 'int' lvalue ->linenumber 0x558fa8ea0308
`-ImplicitCastExpr 0x558fa8f25020 <col:22> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f24ff8 <col:22> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B4.14]->linenumber
  16: ImplicitCastExpr 0x558fa8f25158 <lparser.c:766:22, col:26> 'int' <LValueToRValue>
`-MemberExpr 0x558fa8f25038 <col:22, col:26> 'int' lvalue ->linenumber 0x558fa8ea0308
  `-ImplicitCastExpr 0x558fa8f25020 <col:22> 'LexState *' <LValueToRValue>
    `-DeclRefExpr 0x558fa8f24ff8 <col:22> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B4.15] (ImplicitCastExpr, LValueToRValue, int)
  17: CallExpr 0x558fa8f250e0 <lparser.c:766:7, col:36> 'void'
|-ImplicitCastExpr 0x558fa8f250c8 <col:7> 'void (*)(LexState *, expdesc *, int, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f24f60 <col:7> 'void (LexState *, expdesc *, int, int)' Function 0x558fa8f1d710 'body' 'void (LexState *, expdesc *, int, int)'
|-ImplicitCastExpr 0x558fa8f25128 <col:12> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f24f88 <col:12> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
|-ImplicitCastExpr 0x558fa8f25140 <col:16> 'expdesc *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f24fb0 <col:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
|-IntegerLiteral 0x558fa8f24fd8 <col:19> 'int' 0
`-ImplicitCastExpr 0x558fa8f25158 <col:22, col:26> 'int' <LValueToRValue>
  `-MemberExpr 0x558fa8f25038 <col:22, col:26> 'int' lvalue ->linenumber 0x558fa8ea0308
    `-ImplicitCastExpr 0x558fa8f25020 <col:22> 'LexState *' <LValueToRValue>
      `-DeclRefExpr 0x558fa8f24ff8 <col:22> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B4.7]([B4.9], [B4.11], [B4.12], [B4.16])
  18: ReturnStmt 0x558fa8f25170 <lparser.c:767:7>
return;
   Preds (1): B2
   Succs (1): B0

 [B5]
  case '{':
   1: DeclRefExpr 0x558fa8f24d20 <lparser.c:761:7> 'void (LexState *, expdesc *)' Function 0x558fa8f17ed0 'constructor' 'void (LexState *, expdesc *)'
constructor
   2: ImplicitCastExpr 0x558fa8f24d98 <lparser.c:761:7> 'void (*)(LexState *, expdesc *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f24d20 <col:7> 'void (LexState *, expdesc *)' Function 0x558fa8f17ed0 'constructor' 'void (LexState *, expdesc *)'
[B5.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *, expdesc *))
   3: DeclRefExpr 0x558fa8f24d48 <lparser.c:761:19> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f24de8 <lparser.c:761:19> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f24d48 <col:19> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B5.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: DeclRefExpr 0x558fa8f24d70 <lparser.c:761:23> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
v
   6: ImplicitCastExpr 0x558fa8f24e00 <lparser.c:761:23> 'expdesc *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f24d70 <col:23> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
[B5.5] (ImplicitCastExpr, LValueToRValue, expdesc *)
   7: CallExpr 0x558fa8f24db0 <lparser.c:761:7, col:24> 'void'
|-ImplicitCastExpr 0x558fa8f24d98 <col:7> 'void (*)(LexState *, expdesc *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f24d20 <col:7> 'void (LexState *, expdesc *)' Function 0x558fa8f17ed0 'constructor' 'void (LexState *, expdesc *)'
|-ImplicitCastExpr 0x558fa8f24de8 <col:19> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f24d48 <col:19> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
`-ImplicitCastExpr 0x558fa8f24e00 <col:23> 'expdesc *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f24d70 <col:23> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
[B5.2]([B5.4], [B5.6])
   8: ReturnStmt 0x558fa8f24e18 <lparser.c:762:7>
return;
   Preds (1): B2
   Succs (1): B0

 [B6]
   1: DeclRefExpr 0x558fa8f248d8 <lparser.c:756:7> 'FuncState *' lvalue Var 0x558fa8f244c0 'fs' 'FuncState *'
fs
   2: ImplicitCastExpr 0x558fa8f24900 <lparser.c:756:7> 'FuncState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f248d8 <col:7> 'FuncState *' lvalue Var 0x558fa8f244c0 'fs' 'FuncState *'
[B6.1] (ImplicitCastExpr, LValueToRValue, FuncState *)
   3: MemberExpr 0x558fa8f24918 <lparser.c:756:7, col:11> 'Proto *' lvalue ->f 0x558fa8eb3e58
`-ImplicitCastExpr 0x558fa8f24900 <col:7> 'FuncState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f248d8 <col:7> 'FuncState *' lvalue Var 0x558fa8f244c0 'fs' 'FuncState *'
[B6.2]->f
   4: ImplicitCastExpr 0x558fa8f24950 <lparser.c:756:7, col:11> 'Proto *' <LValueToRValue>
`-MemberExpr 0x558fa8f24918 <col:7, col:11> 'Proto *' lvalue ->f 0x558fa8eb3e58
  `-ImplicitCastExpr 0x558fa8f24900 <col:7> 'FuncState *' <LValueToRValue>
    `-DeclRefExpr 0x558fa8f248d8 <col:7> 'FuncState *' lvalue Var 0x558fa8f244c0 'fs' 'FuncState *'
[B6.3] (ImplicitCastExpr, LValueToRValue, Proto *)
   5: MemberExpr 0x558fa8f24968 <lparser.c:756:7, col:14> 'lu_byte':'unsigned char' lvalue ->is_vararg 0x558fa8e8f848
`-ImplicitCastExpr 0x558fa8f24950 <col:7, col:11> 'Proto *' <LValueToRValue>
  `-MemberExpr 0x558fa8f24918 <col:7, col:11> 'Proto *' lvalue ->f 0x558fa8eb3e58
    `-ImplicitCastExpr 0x558fa8f24900 <col:7> 'FuncState *' <LValueToRValue>
      `-DeclRefExpr 0x558fa8f248d8 <col:7> 'FuncState *' lvalue Var 0x558fa8f244c0 'fs' 'FuncState *'
[B6.4]->is_vararg
   6: IntegerLiteral 0x558fa8f249a0 <./lobject.h:259:26> 'int' 4
4
   7: UnaryOperator 0x558fa8f249c0 <lparser.c:756:27, ./lobject.h:259:26> 'int' prefix '~'
`-IntegerLiteral 0x558fa8f249a0 <col:26> 'int' 4
~[B6.6]
   8: CompoundAssignOperator 0x558fa8f249e0 <lparser.c:756:7, ./lobject.h:259:26> 'lu_byte':'unsigned char' '&=' ComputeLHSTy='int' ComputeResultTy='int'
|-MemberExpr 0x558fa8f24968 <lparser.c:756:7, col:14> 'lu_byte':'unsigned char' lvalue ->is_vararg 0x558fa8e8f848
| `-ImplicitCastExpr 0x558fa8f24950 <col:7, col:11> 'Proto *' <LValueToRValue>
|   `-MemberExpr 0x558fa8f24918 <col:7, col:11> 'Proto *' lvalue ->f 0x558fa8eb3e58
|     `-ImplicitCastExpr 0x558fa8f24900 <col:7> 'FuncState *' <LValueToRValue>
|       `-DeclRefExpr 0x558fa8f248d8 <col:7> 'FuncState *' lvalue Var 0x558fa8f244c0 'fs' 'FuncState *'
`-UnaryOperator 0x558fa8f249c0 <col:27, ./lobject.h:259:26> 'int' prefix '~'
  `-IntegerLiteral 0x558fa8f249a0 <col:26> 'int' 4
[B6.5] &= [B6.7]
   9: DeclRefExpr 0x558fa8f24a18 <lparser.c:757:7> 'void (expdesc *, expkind, int)' Function 0x558fa8eef950 'init_exp' 'void (expdesc *, expkind, int)'
init_exp
  10: ImplicitCastExpr 0x558fa8f24c00 <lparser.c:757:7> 'void (*)(expdesc *, expkind, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f24a18 <col:7> 'void (expdesc *, expkind, int)' Function 0x558fa8eef950 'init_exp' 'void (expdesc *, expkind, int)'
[B6.9] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(expdesc *, expkind, int))
  11: DeclRefExpr 0x558fa8f24a40 <lparser.c:757:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
v
  12: ImplicitCastExpr 0x558fa8f24c58 <lparser.c:757:16> 'expdesc *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f24a40 <col:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
[B6.11] (ImplicitCastExpr, LValueToRValue, expdesc *)
  13: DeclRefExpr 0x558fa8f24a68 <lparser.c:757:19> 'int' EnumConstant 0x558fa8eb0c80 'VVARARG' 'int'
VVARARG
  14: ImplicitCastExpr 0x558fa8f24c70 <lparser.c:757:19> 'expkind':'expkind' <IntegralCast>
`-DeclRefExpr 0x558fa8f24a68 <col:19> 'int' EnumConstant 0x558fa8eb0c80 'VVARARG' 'int'
[B6.13] (ImplicitCastExpr, IntegralCast, expkind)
  15: DeclRefExpr 0x558fa8f24a90 <lparser.c:757:28> 'int (FuncState *, OpCode, int, int, int)' Function 0x558fa8eb9498 'luaK_codeABC' 'int (FuncState *, OpCode, int, int, int)'
luaK_codeABC
  16: ImplicitCastExpr 0x558fa8f24b68 <lparser.c:757:28> 'int (*)(FuncState *, OpCode, int, int, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f24a90 <col:28> 'int (FuncState *, OpCode, int, int, int)' Function 0x558fa8eb9498 'luaK_codeABC' 'int (FuncState *, OpCode, int, int, int)'
[B6.15] (ImplicitCastExpr, FunctionToPointerDecay, int (*)(FuncState *, OpCode, int, int, int))
  17: DeclRefExpr 0x558fa8f24ab8 <lparser.c:757:41> 'FuncState *' lvalue Var 0x558fa8f244c0 'fs' 'FuncState *'
fs
  18: ImplicitCastExpr 0x558fa8f24bd0 <lparser.c:757:41> 'FuncState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f24ab8 <col:41> 'FuncState *' lvalue Var 0x558fa8f244c0 'fs' 'FuncState *'
[B6.17] (ImplicitCastExpr, LValueToRValue, FuncState *)
  19: DeclRefExpr 0x558fa8f24ae0 <lparser.c:757:45> 'int' EnumConstant 0x558fa8eafd88 'OP_VARARG' 'int'
OP_VARARG
  20: ImplicitCastExpr 0x558fa8f24be8 <lparser.c:757:45> 'OpCode':'OpCode' <IntegralCast>
`-DeclRefExpr 0x558fa8f24ae0 <col:45> 'int' EnumConstant 0x558fa8eafd88 'OP_VARARG' 'int'
[B6.19] (ImplicitCastExpr, IntegralCast, OpCode)
  21: IntegerLiteral 0x558fa8f24b08 <lparser.c:757:56> 'int' 0
0
  22: IntegerLiteral 0x558fa8f24b28 <lparser.c:757:59> 'int' 1
1
  23: IntegerLiteral 0x558fa8f24b48 <lparser.c:757:62> 'int' 0
0
  24: CallExpr 0x558fa8f24b80 <lparser.c:757:28, col:63> 'int'
|-ImplicitCastExpr 0x558fa8f24b68 <col:28> 'int (*)(FuncState *, OpCode, int, int, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f24a90 <col:28> 'int (FuncState *, OpCode, int, int, int)' Function 0x558fa8eb9498 'luaK_codeABC' 'int (FuncState *, OpCode, int, int, int)'
|-ImplicitCastExpr 0x558fa8f24bd0 <col:41> 'FuncState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f24ab8 <col:41> 'FuncState *' lvalue Var 0x558fa8f244c0 'fs' 'FuncState *'
|-ImplicitCastExpr 0x558fa8f24be8 <col:45> 'OpCode':'OpCode' <IntegralCast>
| `-DeclRefExpr 0x558fa8f24ae0 <col:45> 'int' EnumConstant 0x558fa8eafd88 'OP_VARARG' 'int'
|-IntegerLiteral 0x558fa8f24b08 <col:56> 'int' 0
|-IntegerLiteral 0x558fa8f24b28 <col:59> 'int' 1
`-IntegerLiteral 0x558fa8f24b48 <col:62> 'int' 0
[B6.16]([B6.18], [B6.20], [B6.21], [B6.22], [B6.23])
  25: CallExpr 0x558fa8f24c18 <lparser.c:757:7, col:64> 'void'
|-ImplicitCastExpr 0x558fa8f24c00 <col:7> 'void (*)(expdesc *, expkind, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f24a18 <col:7> 'void (expdesc *, expkind, int)' Function 0x558fa8eef950 'init_exp' 'void (expdesc *, expkind, int)'
|-ImplicitCastExpr 0x558fa8f24c58 <col:16> 'expdesc *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f24a40 <col:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
|-ImplicitCastExpr 0x558fa8f24c70 <col:19> 'expkind':'expkind' <IntegralCast>
| `-DeclRefExpr 0x558fa8f24a68 <col:19> 'int' EnumConstant 0x558fa8eb0c80 'VVARARG' 'int'
`-CallExpr 0x558fa8f24b80 <col:28, col:63> 'int'
  |-ImplicitCastExpr 0x558fa8f24b68 <col:28> 'int (*)(FuncState *, OpCode, int, int, int)' <FunctionToPointerDecay>
  | `-DeclRefExpr 0x558fa8f24a90 <col:28> 'int (FuncState *, OpCode, int, int, int)' Function 0x558fa8eb9498 'luaK_codeABC' 'int (FuncState *, OpCode, int, int, int)'
  |-ImplicitCastExpr 0x558fa8f24bd0 <col:41> 'FuncState *' <LValueToRValue>
  | `-DeclRefExpr 0x558fa8f24ab8 <col:41> 'FuncState *' lvalue Var 0x558fa8f244c0 'fs' 'FuncState *'
  |-ImplicitCastExpr 0x558fa8f24be8 <col:45> 'OpCode':'OpCode' <IntegralCast>
  | `-DeclRefExpr 0x558fa8f24ae0 <col:45> 'int' EnumConstant 0x558fa8eafd88 'OP_VARARG' 'int'
  |-IntegerLiteral 0x558fa8f24b08 <col:56> 'int' 0
  |-IntegerLiteral 0x558fa8f24b28 <col:59> 'int' 1
  `-IntegerLiteral 0x558fa8f24b48 <col:62> 'int' 0
[B6.10]([B6.12], [B6.14], [B6.24])
   T: break;
   Preds (2): B7 B8
   Succs (1): B1

 [B7]
   1: DeclRefExpr 0x558fa8f246e8 <lparser.c:100:47> 'void (LexState *, const char *)' Function 0x558fa8ea1c10 'luaX_syntaxerror' 'void (LexState *, const char *)'
luaX_syntaxerror
   2: ImplicitCastExpr 0x558fa8f247e0 <lparser.c:100:47> 'void (*)(LexState *, const char *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f246e8 <col:47> 'void (LexState *, const char *)' Function 0x558fa8ea1c10 'luaX_syntaxerror' 'void (LexState *, const char *)'
[B7.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *, const char *))
   3: DeclRefExpr 0x558fa8f24710 <lparser.c:754:23> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f24830 <lparser.c:754:23> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f24710 <col:23> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B7.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: StringLiteral 0x558fa8f24778 <lparser.c:755:23, col:51> 'char [43]' lvalue "cannot use '...' outside a vararg function"
"cannot use '...' outside a vararg function"
   6: ImplicitCastExpr 0x558fa8f24848 <lparser.c:755:23, col:51> 'char *' <ArrayToPointerDecay>
`-StringLiteral 0x558fa8f24778 <col:23, col:51> 'char [43]' lvalue "cannot use '...' outside a vararg function"
[B7.5] (ImplicitCastExpr, ArrayToPointerDecay, char *)
   7: ImplicitCastExpr 0x558fa8f24860 <lparser.c:755:23, col:51> 'const char *' <BitCast>
`-ImplicitCastExpr 0x558fa8f24848 <col:23, col:51> 'char *' <ArrayToPointerDecay>
  `-StringLiteral 0x558fa8f24778 <col:23, col:51> 'char [43]' lvalue "cannot use '...' outside a vararg function"
[B7.6] (ImplicitCastExpr, BitCast, const char *)
   8: CallExpr 0x558fa8f247f8 <lparser.c:100:47, col:71> 'void'
|-ImplicitCastExpr 0x558fa8f247e0 <col:47> 'void (*)(LexState *, const char *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f246e8 <col:47> 'void (LexState *, const char *)' Function 0x558fa8ea1c10 'luaX_syntaxerror' 'void (LexState *, const char *)'
|-ImplicitCastExpr 0x558fa8f24830 <line:754:23> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f24710 <col:23> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
`-ImplicitCastExpr 0x558fa8f24860 <line:755:23, col:51> 'const char *' <BitCast>
  `-ImplicitCastExpr 0x558fa8f24848 <col:23, col:51> 'char *' <ArrayToPointerDecay>
    `-StringLiteral 0x558fa8f24778 <col:23, col:51> 'char [43]' lvalue "cannot use '...' outside a vararg function"
[B7.2]([B7.4], [B7.7])
   Preds (1): B8
   Succs (1): B6

 [B8]
  case TK_DOTS:
   1: DeclRefExpr 0x558fa8f24520 <lparser.c:753:23> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
ls
   2: ImplicitCastExpr 0x558fa8f24548 <lparser.c:753:23> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f24520 <col:23> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B8.1] (ImplicitCastExpr, LValueToRValue, LexState *)
   3: MemberExpr 0x558fa8f24560 <lparser.c:753:23, col:27> 'struct FuncState *' lvalue ->fs 0x558fa8ea05f0
`-ImplicitCastExpr 0x558fa8f24548 <col:23> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f24520 <col:23> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B8.2]->fs
   4: ImplicitCastExpr 0x558fa8f24598 <lparser.c:753:23, col:27> 'struct FuncState *' <LValueToRValue>
`-MemberExpr 0x558fa8f24560 <col:23, col:27> 'struct FuncState *' lvalue ->fs 0x558fa8ea05f0
  `-ImplicitCastExpr 0x558fa8f24548 <col:23> 'LexState *' <LValueToRValue>
    `-DeclRefExpr 0x558fa8f24520 <col:23> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B8.3] (ImplicitCastExpr, LValueToRValue, struct FuncState *)
   5: DeclStmt 0x558fa8f245b0 <lparser.c:753:7, col:29>col:18
`-VarDecl 0x558fa8f244c0 <col:7, col:27> col:18 used fs 'FuncState *' cinit
  `-ImplicitCastExpr 0x558fa8f24598 <col:23, col:27> 'struct FuncState *' <LValueToRValue>
    `-MemberExpr 0x558fa8f24560 <col:23, col:27> 'struct FuncState *' lvalue ->fs 0x558fa8ea05f0
      `-ImplicitCastExpr 0x558fa8f24548 <col:23> 'LexState *' <LValueToRValue>
        `-DeclRefExpr 0x558fa8f24520 <col:23> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
FuncState *fs = ls->fs;
   6: DeclRefExpr 0x558fa8f245c8 <lparser.c:754:27> 'FuncState *' lvalue Var 0x558fa8f244c0 'fs' 'FuncState *'
fs
   7: ImplicitCastExpr 0x558fa8f245f0 <lparser.c:754:27> 'FuncState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f245c8 <col:27> 'FuncState *' lvalue Var 0x558fa8f244c0 'fs' 'FuncState *'
[B8.6] (ImplicitCastExpr, LValueToRValue, FuncState *)
   8: MemberExpr 0x558fa8f24608 <lparser.c:754:27, col:31> 'Proto *' lvalue ->f 0x558fa8eb3e58
`-ImplicitCastExpr 0x558fa8f245f0 <col:27> 'FuncState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f245c8 <col:27> 'FuncState *' lvalue Var 0x558fa8f244c0 'fs' 'FuncState *'
[B8.7]->f
   9: ImplicitCastExpr 0x558fa8f24640 <lparser.c:754:27, col:31> 'Proto *' <LValueToRValue>
`-MemberExpr 0x558fa8f24608 <col:27, col:31> 'Proto *' lvalue ->f 0x558fa8eb3e58
  `-ImplicitCastExpr 0x558fa8f245f0 <col:27> 'FuncState *' <LValueToRValue>
    `-DeclRefExpr 0x558fa8f245c8 <col:27> 'FuncState *' lvalue Var 0x558fa8f244c0 'fs' 'FuncState *'
[B8.8] (ImplicitCastExpr, LValueToRValue, Proto *)
  10: MemberExpr 0x558fa8f24658 <lparser.c:754:27, col:34> 'lu_byte':'unsigned char' lvalue ->is_vararg 0x558fa8e8f848
`-ImplicitCastExpr 0x558fa8f24640 <col:27, col:31> 'Proto *' <LValueToRValue>
  `-MemberExpr 0x558fa8f24608 <col:27, col:31> 'Proto *' lvalue ->f 0x558fa8eb3e58
    `-ImplicitCastExpr 0x558fa8f245f0 <col:27> 'FuncState *' <LValueToRValue>
      `-DeclRefExpr 0x558fa8f245c8 <col:27> 'FuncState *' lvalue Var 0x558fa8f244c0 'fs' 'FuncState *'
[B8.9]->is_vararg
  11: ImplicitCastExpr 0x558fa8f246b0 <lparser.c:100:42, col:44> 'lu_byte':'unsigned char' <LValueToRValue>
`-ParenExpr 0x558fa8f24690 <col:42, col:44> 'lu_byte':'unsigned char' lvalue
  `-MemberExpr 0x558fa8f24658 <line:754:27, col:34> 'lu_byte':'unsigned char' lvalue ->is_vararg 0x558fa8e8f848
    `-ImplicitCastExpr 0x558fa8f24640 <col:27, col:31> 'Proto *' <LValueToRValue>
      `-MemberExpr 0x558fa8f24608 <col:27, col:31> 'Proto *' lvalue ->f 0x558fa8eb3e58
        `-ImplicitCastExpr 0x558fa8f245f0 <col:27> 'FuncState *' <LValueToRValue>
          `-DeclRefExpr 0x558fa8f245c8 <col:27> 'FuncState *' lvalue Var 0x558fa8f244c0 'fs' 'FuncState *'
([B8.10]) (ImplicitCastExpr, LValueToRValue, lu_byte)
  12: UnaryOperator 0x558fa8f246c8 <lparser.c:100:41, col:44> 'int' prefix '!'
`-ImplicitCastExpr 0x558fa8f246b0 <col:42, col:44> 'lu_byte':'unsigned char' <LValueToRValue>
  `-ParenExpr 0x558fa8f24690 <col:42, col:44> 'lu_byte':'unsigned char' lvalue
    `-MemberExpr 0x558fa8f24658 <line:754:27, col:34> 'lu_byte':'unsigned char' lvalue ->is_vararg 0x558fa8e8f848
      `-ImplicitCastExpr 0x558fa8f24640 <col:27, col:31> 'Proto *' <LValueToRValue>
        `-MemberExpr 0x558fa8f24608 <col:27, col:31> 'Proto *' lvalue ->f 0x558fa8eb3e58
          `-ImplicitCastExpr 0x558fa8f245f0 <col:27> 'FuncState *' <LValueToRValue>
            `-DeclRefExpr 0x558fa8f245c8 <col:27> 'FuncState *' lvalue Var 0x558fa8f244c0 'fs' 'FuncState *'
![B8.11]
   T: if [B8.12]
   Preds (1): B2
   Succs (2): B7 B6

 [B9]
  case TK_FALSE:
   1: DeclRefExpr 0x558fa8f24308 <lparser.c:749:7> 'void (expdesc *, expkind, int)' Function 0x558fa8eef950 'init_exp' 'void (expdesc *, expkind, int)'
init_exp
   2: ImplicitCastExpr 0x558fa8f243a0 <lparser.c:749:7> 'void (*)(expdesc *, expkind, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f24308 <col:7> 'void (expdesc *, expkind, int)' Function 0x558fa8eef950 'init_exp' 'void (expdesc *, expkind, int)'
[B9.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(expdesc *, expkind, int))
   3: DeclRefExpr 0x558fa8f24330 <lparser.c:749:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
v
   4: ImplicitCastExpr 0x558fa8f243f8 <lparser.c:749:16> 'expdesc *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f24330 <col:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
[B9.3] (ImplicitCastExpr, LValueToRValue, expdesc *)
   5: DeclRefExpr 0x558fa8f24358 <lparser.c:749:19> 'int' EnumConstant 0x558fa8eb0968 'VFALSE' 'int'
VFALSE
   6: ImplicitCastExpr 0x558fa8f24410 <lparser.c:749:19> 'expkind':'expkind' <IntegralCast>
`-DeclRefExpr 0x558fa8f24358 <col:19> 'int' EnumConstant 0x558fa8eb0968 'VFALSE' 'int'
[B9.5] (ImplicitCastExpr, IntegralCast, expkind)
   7: IntegerLiteral 0x558fa8f24380 <lparser.c:749:27> 'int' 0
0
   8: CallExpr 0x558fa8f243b8 <lparser.c:749:7, col:28> 'void'
|-ImplicitCastExpr 0x558fa8f243a0 <col:7> 'void (*)(expdesc *, expkind, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f24308 <col:7> 'void (expdesc *, expkind, int)' Function 0x558fa8eef950 'init_exp' 'void (expdesc *, expkind, int)'
|-ImplicitCastExpr 0x558fa8f243f8 <col:16> 'expdesc *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f24330 <col:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
|-ImplicitCastExpr 0x558fa8f24410 <col:19> 'expkind':'expkind' <IntegralCast>
| `-DeclRefExpr 0x558fa8f24358 <col:19> 'int' EnumConstant 0x558fa8eb0968 'VFALSE' 'int'
`-IntegerLiteral 0x558fa8f24380 <col:27> 'int' 0
[B9.2]([B9.4], [B9.6], [B9.7])
   T: break;
   Preds (1): B2
   Succs (1): B1

 [B10]
  case TK_TRUE:
   1: DeclRefExpr 0x558fa8f24160 <lparser.c:745:7> 'void (expdesc *, expkind, int)' Function 0x558fa8eef950 'init_exp' 'void (expdesc *, expkind, int)'
init_exp
   2: ImplicitCastExpr 0x558fa8f241f8 <lparser.c:745:7> 'void (*)(expdesc *, expkind, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f24160 <col:7> 'void (expdesc *, expkind, int)' Function 0x558fa8eef950 'init_exp' 'void (expdesc *, expkind, int)'
[B10.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(expdesc *, expkind, int))
   3: DeclRefExpr 0x558fa8f24188 <lparser.c:745:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
v
   4: ImplicitCastExpr 0x558fa8f24250 <lparser.c:745:16> 'expdesc *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f24188 <col:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
[B10.3] (ImplicitCastExpr, LValueToRValue, expdesc *)
   5: DeclRefExpr 0x558fa8f241b0 <lparser.c:745:19> 'int' EnumConstant 0x558fa8eb0920 'VTRUE' 'int'
VTRUE
   6: ImplicitCastExpr 0x558fa8f24268 <lparser.c:745:19> 'expkind':'expkind' <IntegralCast>
`-DeclRefExpr 0x558fa8f241b0 <col:19> 'int' EnumConstant 0x558fa8eb0920 'VTRUE' 'int'
[B10.5] (ImplicitCastExpr, IntegralCast, expkind)
   7: IntegerLiteral 0x558fa8f241d8 <lparser.c:745:26> 'int' 0
0
   8: CallExpr 0x558fa8f24210 <lparser.c:745:7, col:27> 'void'
|-ImplicitCastExpr 0x558fa8f241f8 <col:7> 'void (*)(expdesc *, expkind, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f24160 <col:7> 'void (expdesc *, expkind, int)' Function 0x558fa8eef950 'init_exp' 'void (expdesc *, expkind, int)'
|-ImplicitCastExpr 0x558fa8f24250 <col:16> 'expdesc *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f24188 <col:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
|-ImplicitCastExpr 0x558fa8f24268 <col:19> 'expkind':'expkind' <IntegralCast>
| `-DeclRefExpr 0x558fa8f241b0 <col:19> 'int' EnumConstant 0x558fa8eb0920 'VTRUE' 'int'
`-IntegerLiteral 0x558fa8f241d8 <col:26> 'int' 0
[B10.2]([B10.4], [B10.6], [B10.7])
   T: break;
   Preds (1): B2
   Succs (1): B1

 [B11]
  case TK_NIL:
   1: DeclRefExpr 0x558fa8f23fb8 <lparser.c:741:7> 'void (expdesc *, expkind, int)' Function 0x558fa8eef950 'init_exp' 'void (expdesc *, expkind, int)'
init_exp
   2: ImplicitCastExpr 0x558fa8f24050 <lparser.c:741:7> 'void (*)(expdesc *, expkind, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f23fb8 <col:7> 'void (expdesc *, expkind, int)' Function 0x558fa8eef950 'init_exp' 'void (expdesc *, expkind, int)'
[B11.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(expdesc *, expkind, int))
   3: DeclRefExpr 0x558fa8f23fe0 <lparser.c:741:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
v
   4: ImplicitCastExpr 0x558fa8f240a8 <lparser.c:741:16> 'expdesc *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f23fe0 <col:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
[B11.3] (ImplicitCastExpr, LValueToRValue, expdesc *)
   5: DeclRefExpr 0x558fa8f24008 <lparser.c:741:19> 'int' EnumConstant 0x558fa8eb08d8 'VNIL' 'int'
VNIL
   6: ImplicitCastExpr 0x558fa8f240c0 <lparser.c:741:19> 'expkind':'expkind' <IntegralCast>
`-DeclRefExpr 0x558fa8f24008 <col:19> 'int' EnumConstant 0x558fa8eb08d8 'VNIL' 'int'
[B11.5] (ImplicitCastExpr, IntegralCast, expkind)
   7: IntegerLiteral 0x558fa8f24030 <lparser.c:741:25> 'int' 0
0
   8: CallExpr 0x558fa8f24068 <lparser.c:741:7, col:26> 'void'
|-ImplicitCastExpr 0x558fa8f24050 <col:7> 'void (*)(expdesc *, expkind, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f23fb8 <col:7> 'void (expdesc *, expkind, int)' Function 0x558fa8eef950 'init_exp' 'void (expdesc *, expkind, int)'
|-ImplicitCastExpr 0x558fa8f240a8 <col:16> 'expdesc *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f23fe0 <col:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
|-ImplicitCastExpr 0x558fa8f240c0 <col:19> 'expkind':'expkind' <IntegralCast>
| `-DeclRefExpr 0x558fa8f24008 <col:19> 'int' EnumConstant 0x558fa8eb08d8 'VNIL' 'int'
`-IntegerLiteral 0x558fa8f24030 <col:25> 'int' 0
[B11.2]([B11.4], [B11.6], [B11.7])
   T: break;
   Preds (1): B2
   Succs (1): B1

 [B12]
  case TK_STRING:
   1: DeclRefExpr 0x558fa8f23d30 <lparser.c:737:7> 'void (LexState *, expdesc *, TString *)' Function 0x558fa8ef0020 'codestring' 'void (LexState *, expdesc *, TString *)'
codestring
   2: ImplicitCastExpr 0x558fa8f23e90 <lparser.c:737:7> 'void (*)(LexState *, expdesc *, TString *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f23d30 <col:7> 'void (LexState *, expdesc *, TString *)' Function 0x558fa8ef0020 'codestring' 'void (LexState *, expdesc *, TString *)'
[B12.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *, expdesc *, TString *))
   3: DeclRefExpr 0x558fa8f23d58 <lparser.c:737:18> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f23ee8 <lparser.c:737:18> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f23d58 <col:18> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B12.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: DeclRefExpr 0x558fa8f23d80 <lparser.c:737:22> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
v
   6: ImplicitCastExpr 0x558fa8f23f00 <lparser.c:737:22> 'expdesc *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f23d80 <col:22> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
[B12.5] (ImplicitCastExpr, LValueToRValue, expdesc *)
   7: DeclRefExpr 0x558fa8f23da8 <lparser.c:737:25> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
ls
   8: ImplicitCastExpr 0x558fa8f23dd0 <lparser.c:737:25> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f23da8 <col:25> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B12.7] (ImplicitCastExpr, LValueToRValue, LexState *)
   9: MemberExpr 0x558fa8f23de8 <lparser.c:737:25, col:29> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
`-ImplicitCastExpr 0x558fa8f23dd0 <col:25> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f23da8 <col:25> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B12.8]->t
  10: MemberExpr 0x558fa8f23e20 <lparser.c:737:25, col:31> 'SemInfo':'SemInfo' lvalue .seminfo 0x558fa8e9ed00
`-MemberExpr 0x558fa8f23de8 <col:25, col:29> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
  `-ImplicitCastExpr 0x558fa8f23dd0 <col:25> 'LexState *' <LValueToRValue>
    `-DeclRefExpr 0x558fa8f23da8 <col:25> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B12.9].seminfo
  11: MemberExpr 0x558fa8f23e58 <lparser.c:737:25, col:39> 'TString *' lvalue .ts 0x558fa8e9eab8
`-MemberExpr 0x558fa8f23e20 <col:25, col:31> 'SemInfo':'SemInfo' lvalue .seminfo 0x558fa8e9ed00
  `-MemberExpr 0x558fa8f23de8 <col:25, col:29> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
    `-ImplicitCastExpr 0x558fa8f23dd0 <col:25> 'LexState *' <LValueToRValue>
      `-DeclRefExpr 0x558fa8f23da8 <col:25> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B12.10].ts
  12: ImplicitCastExpr 0x558fa8f23f18 <lparser.c:737:25, col:39> 'TString *' <LValueToRValue>
`-MemberExpr 0x558fa8f23e58 <col:25, col:39> 'TString *' lvalue .ts 0x558fa8e9eab8
  `-MemberExpr 0x558fa8f23e20 <col:25, col:31> 'SemInfo':'SemInfo' lvalue .seminfo 0x558fa8e9ed00
    `-MemberExpr 0x558fa8f23de8 <col:25, col:29> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
      `-ImplicitCastExpr 0x558fa8f23dd0 <col:25> 'LexState *' <LValueToRValue>
        `-DeclRefExpr 0x558fa8f23da8 <col:25> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B12.11] (ImplicitCastExpr, LValueToRValue, TString *)
  13: CallExpr 0x558fa8f23ea8 <lparser.c:737:7, col:41> 'void'
|-ImplicitCastExpr 0x558fa8f23e90 <col:7> 'void (*)(LexState *, expdesc *, TString *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f23d30 <col:7> 'void (LexState *, expdesc *, TString *)' Function 0x558fa8ef0020 'codestring' 'void (LexState *, expdesc *, TString *)'
|-ImplicitCastExpr 0x558fa8f23ee8 <col:18> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f23d58 <col:18> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
|-ImplicitCastExpr 0x558fa8f23f00 <col:22> 'expdesc *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f23d80 <col:22> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
`-ImplicitCastExpr 0x558fa8f23f18 <col:25, col:39> 'TString *' <LValueToRValue>
  `-MemberExpr 0x558fa8f23e58 <col:25, col:39> 'TString *' lvalue .ts 0x558fa8e9eab8
    `-MemberExpr 0x558fa8f23e20 <col:25, col:31> 'SemInfo':'SemInfo' lvalue .seminfo 0x558fa8e9ed00
      `-MemberExpr 0x558fa8f23de8 <col:25, col:29> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
        `-ImplicitCastExpr 0x558fa8f23dd0 <col:25> 'LexState *' <LValueToRValue>
          `-DeclRefExpr 0x558fa8f23da8 <col:25> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B12.2]([B12.4], [B12.6], [B12.12])
   T: break;
   Preds (1): B2
   Succs (1): B1

 [B13]
  case TK_NUMBER:
   1: DeclRefExpr 0x558fa8f239a8 <lparser.c:732:7> 'void (expdesc *, expkind, int)' Function 0x558fa8eef950 'init_exp' 'void (expdesc *, expkind, int)'
init_exp
   2: ImplicitCastExpr 0x558fa8f23a40 <lparser.c:732:7> 'void (*)(expdesc *, expkind, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f239a8 <col:7> 'void (expdesc *, expkind, int)' Function 0x558fa8eef950 'init_exp' 'void (expdesc *, expkind, int)'
[B13.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(expdesc *, expkind, int))
   3: DeclRefExpr 0x558fa8f239d0 <lparser.c:732:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
v
   4: ImplicitCastExpr 0x558fa8f23a98 <lparser.c:732:16> 'expdesc *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f239d0 <col:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
[B13.3] (ImplicitCastExpr, LValueToRValue, expdesc *)
   5: DeclRefExpr 0x558fa8f239f8 <lparser.c:732:19> 'int' EnumConstant 0x558fa8eb09f8 'VKNUM' 'int'
VKNUM
   6: ImplicitCastExpr 0x558fa8f23ab0 <lparser.c:732:19> 'expkind':'expkind' <IntegralCast>
`-DeclRefExpr 0x558fa8f239f8 <col:19> 'int' EnumConstant 0x558fa8eb09f8 'VKNUM' 'int'
[B13.5] (ImplicitCastExpr, IntegralCast, expkind)
   7: IntegerLiteral 0x558fa8f23a20 <lparser.c:732:26> 'int' 0
0
   8: CallExpr 0x558fa8f23a58 <lparser.c:732:7, col:27> 'void'
|-ImplicitCastExpr 0x558fa8f23a40 <col:7> 'void (*)(expdesc *, expkind, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f239a8 <col:7> 'void (expdesc *, expkind, int)' Function 0x558fa8eef950 'init_exp' 'void (expdesc *, expkind, int)'
|-ImplicitCastExpr 0x558fa8f23a98 <col:16> 'expdesc *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f239d0 <col:16> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
|-ImplicitCastExpr 0x558fa8f23ab0 <col:19> 'expkind':'expkind' <IntegralCast>
| `-DeclRefExpr 0x558fa8f239f8 <col:19> 'int' EnumConstant 0x558fa8eb09f8 'VKNUM' 'int'
`-IntegerLiteral 0x558fa8f23a20 <col:26> 'int' 0
[B13.2]([B13.4], [B13.6], [B13.7])
   9: DeclRefExpr 0x558fa8f23b78 <lparser.c:733:19> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
ls
  10: ImplicitCastExpr 0x558fa8f23ba0 <lparser.c:733:19> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f23b78 <col:19> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B13.9] (ImplicitCastExpr, LValueToRValue, LexState *)
  11: MemberExpr 0x558fa8f23bb8 <lparser.c:733:19, col:23> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
`-ImplicitCastExpr 0x558fa8f23ba0 <col:19> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f23b78 <col:19> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B13.10]->t
  12: MemberExpr 0x558fa8f23bf0 <lparser.c:733:19, col:25> 'SemInfo':'SemInfo' lvalue .seminfo 0x558fa8e9ed00
`-MemberExpr 0x558fa8f23bb8 <col:19, col:23> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
  `-ImplicitCastExpr 0x558fa8f23ba0 <col:19> 'LexState *' <LValueToRValue>
    `-DeclRefExpr 0x558fa8f23b78 <col:19> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B13.11].seminfo
  13: MemberExpr 0x558fa8f23c28 <lparser.c:733:19, col:33> 'lua_Number':'double' lvalue .r 0x558fa8e9ea60
`-MemberExpr 0x558fa8f23bf0 <col:19, col:25> 'SemInfo':'SemInfo' lvalue .seminfo 0x558fa8e9ed00
  `-MemberExpr 0x558fa8f23bb8 <col:19, col:23> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
    `-ImplicitCastExpr 0x558fa8f23ba0 <col:19> 'LexState *' <LValueToRValue>
      `-DeclRefExpr 0x558fa8f23b78 <col:19> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B13.12].r
  14: ImplicitCastExpr 0x558fa8f23c60 <lparser.c:733:19, col:33> 'lua_Number':'double' <LValueToRValue>
`-MemberExpr 0x558fa8f23c28 <col:19, col:33> 'lua_Number':'double' lvalue .r 0x558fa8e9ea60
  `-MemberExpr 0x558fa8f23bf0 <col:19, col:25> 'SemInfo':'SemInfo' lvalue .seminfo 0x558fa8e9ed00
    `-MemberExpr 0x558fa8f23bb8 <col:19, col:23> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
      `-ImplicitCastExpr 0x558fa8f23ba0 <col:19> 'LexState *' <LValueToRValue>
        `-DeclRefExpr 0x558fa8f23b78 <col:19> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B13.13] (ImplicitCastExpr, LValueToRValue, lua_Number)
  15: DeclRefExpr 0x558fa8f23ac8 <lparser.c:733:7> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
v
  16: ImplicitCastExpr 0x558fa8f23af0 <lparser.c:733:7> 'expdesc *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f23ac8 <col:7> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
[B13.15] (ImplicitCastExpr, LValueToRValue, expdesc *)
  17: MemberExpr 0x558fa8f23b08 <lparser.c:733:7, col:10> 'union (anonymous union at ./lparser.h:39:3)':'union expdesc::(anonymous at ./lparser.h:39:3)' lvalue ->u 0x558fa8eb1260
`-ImplicitCastExpr 0x558fa8f23af0 <col:7> 'expdesc *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f23ac8 <col:7> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
[B13.16]->u
  18: MemberExpr 0x558fa8f23b40 <lparser.c:733:7, col:12> 'lua_Number':'double' lvalue .nval 0x558fa8eb1178
`-MemberExpr 0x558fa8f23b08 <col:7, col:10> 'union (anonymous union at ./lparser.h:39:3)':'union expdesc::(anonymous at ./lparser.h:39:3)' lvalue ->u 0x558fa8eb1260
  `-ImplicitCastExpr 0x558fa8f23af0 <col:7> 'expdesc *' <LValueToRValue>
    `-DeclRefExpr 0x558fa8f23ac8 <col:7> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
[B13.17].nval
  19: BinaryOperator 0x558fa8f23c78 <lparser.c:733:7, col:33> 'lua_Number':'double' '='
|-MemberExpr 0x558fa8f23b40 <col:7, col:12> 'lua_Number':'double' lvalue .nval 0x558fa8eb1178
| `-MemberExpr 0x558fa8f23b08 <col:7, col:10> 'union (anonymous union at ./lparser.h:39:3)':'union expdesc::(anonymous at ./lparser.h:39:3)' lvalue ->u 0x558fa8eb1260
|   `-ImplicitCastExpr 0x558fa8f23af0 <col:7> 'expdesc *' <LValueToRValue>
|     `-DeclRefExpr 0x558fa8f23ac8 <col:7> 'expdesc *' lvalue ParmVar 0x558fa8f23710 'v' 'expdesc *'
`-ImplicitCastExpr 0x558fa8f23c60 <col:19, col:33> 'lua_Number':'double' <LValueToRValue>
  `-MemberExpr 0x558fa8f23c28 <col:19, col:33> 'lua_Number':'double' lvalue .r 0x558fa8e9ea60
    `-MemberExpr 0x558fa8f23bf0 <col:19, col:25> 'SemInfo':'SemInfo' lvalue .seminfo 0x558fa8e9ed00
      `-MemberExpr 0x558fa8f23bb8 <col:19, col:23> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
        `-ImplicitCastExpr 0x558fa8f23ba0 <col:19> 'LexState *' <LValueToRValue>
          `-DeclRefExpr 0x558fa8f23b78 <col:19> 'LexState *' lvalue ParmVar 0x558fa8f236a0 'ls' 'LexState *'
[B13.18] = [B13.14]
   T: break;
   Preds (1): B2
   Succs (1): B1

 [B0 (EXIT)]
   Preds (4): B1 B3 B4 B5
