void luaX_lookahead(LexState *ls)
 [B2 (ENTRY)]
   Succs (1): B1

 [B1]
   1: IntegerLiteral 0x561ce746d128 <./llimits.h:62:31> 'int' 0
0
   2: CStyleCastExpr 0x561ce746d158 <./llimits.h:62:25, col:31> 'void' <ToVoid>
`-IntegerLiteral 0x561ce746d128 <col:31> 'int' 0
(void)[B1.1] (CStyleCastExpr, ToVoid, void)
   3: DeclRefExpr 0x561ce746d250 <llex.c:461:25> 'int (LexState *, SemInfo *)' Function 0x561ce7461848 'llex' 'int (LexState *, SemInfo *)'
llex
   4: ImplicitCastExpr 0x561ce746d370 <llex.c:461:25> 'int (*)(LexState *, SemInfo *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x561ce746d250 <col:25> 'int (LexState *, SemInfo *)' Function 0x561ce7461848 'llex' 'int (LexState *, SemInfo *)'
[B1.3] (ImplicitCastExpr, FunctionToPointerDecay, int (*)(LexState *, SemInfo *))
   5: DeclRefExpr 0x561ce746d278 <llex.c:461:30> 'LexState *' lvalue ParmVar 0x561ce746cfb0 'ls' 'LexState *'
ls
   6: ImplicitCastExpr 0x561ce746d3c0 <llex.c:461:30> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x561ce746d278 <col:30> 'LexState *' lvalue ParmVar 0x561ce746cfb0 'ls' 'LexState *'
[B1.5] (ImplicitCastExpr, LValueToRValue, LexState *)
   7: DeclRefExpr 0x561ce746d2a0 <llex.c:461:35> 'LexState *' lvalue ParmVar 0x561ce746cfb0 'ls' 'LexState *'
ls
   8: ImplicitCastExpr 0x561ce746d2c8 <llex.c:461:35> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x561ce746d2a0 <col:35> 'LexState *' lvalue ParmVar 0x561ce746cfb0 'ls' 'LexState *'
[B1.7] (ImplicitCastExpr, LValueToRValue, LexState *)
   9: MemberExpr 0x561ce746d2e0 <llex.c:461:35, col:39> 'Token':'struct Token' lvalue ->lookahead 0x561ce7426988
`-ImplicitCastExpr 0x561ce746d2c8 <col:35> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x561ce746d2a0 <col:35> 'LexState *' lvalue ParmVar 0x561ce746cfb0 'ls' 'LexState *'
[B1.8]->lookahead
  10: MemberExpr 0x561ce746d318 <llex.c:461:35, col:49> 'SemInfo':'SemInfo' lvalue .seminfo 0x561ce7425420
`-MemberExpr 0x561ce746d2e0 <col:35, col:39> 'Token':'struct Token' lvalue ->lookahead 0x561ce7426988
  `-ImplicitCastExpr 0x561ce746d2c8 <col:35> 'LexState *' <LValueToRValue>
    `-DeclRefExpr 0x561ce746d2a0 <col:35> 'LexState *' lvalue ParmVar 0x561ce746cfb0 'ls' 'LexState *'
[B1.9].seminfo
  11: UnaryOperator 0x561ce746d350 <llex.c:461:34, col:49> 'SemInfo *' prefix '&'
`-MemberExpr 0x561ce746d318 <col:35, col:49> 'SemInfo':'SemInfo' lvalue .seminfo 0x561ce7425420
  `-MemberExpr 0x561ce746d2e0 <col:35, col:39> 'Token':'struct Token' lvalue ->lookahead 0x561ce7426988
    `-ImplicitCastExpr 0x561ce746d2c8 <col:35> 'LexState *' <LValueToRValue>
      `-DeclRefExpr 0x561ce746d2a0 <col:35> 'LexState *' lvalue ParmVar 0x561ce746cfb0 'ls' 'LexState *'
&[B1.10]
  12: CallExpr 0x561ce746d388 <llex.c:461:25, col:56> 'int'
|-ImplicitCastExpr 0x561ce746d370 <col:25> 'int (*)(LexState *, SemInfo *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x561ce746d250 <col:25> 'int (LexState *, SemInfo *)' Function 0x561ce7461848 'llex' 'int (LexState *, SemInfo *)'
|-ImplicitCastExpr 0x561ce746d3c0 <col:30> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x561ce746d278 <col:30> 'LexState *' lvalue ParmVar 0x561ce746cfb0 'ls' 'LexState *'
`-UnaryOperator 0x561ce746d350 <col:34, col:49> 'SemInfo *' prefix '&'
  `-MemberExpr 0x561ce746d318 <col:35, col:49> 'SemInfo':'SemInfo' lvalue .seminfo 0x561ce7425420
    `-MemberExpr 0x561ce746d2e0 <col:35, col:39> 'Token':'struct Token' lvalue ->lookahead 0x561ce7426988
      `-ImplicitCastExpr 0x561ce746d2c8 <col:35> 'LexState *' <LValueToRValue>
        `-DeclRefExpr 0x561ce746d2a0 <col:35> 'LexState *' lvalue ParmVar 0x561ce746cfb0 'ls' 'LexState *'
[B1.4]([B1.6], [B1.11])
  13: DeclRefExpr 0x561ce746d1a0 <llex.c:461:3> 'LexState *' lvalue ParmVar 0x561ce746cfb0 'ls' 'LexState *'
ls
  14: ImplicitCastExpr 0x561ce746d1c8 <llex.c:461:3> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x561ce746d1a0 <col:3> 'LexState *' lvalue ParmVar 0x561ce746cfb0 'ls' 'LexState *'
[B1.13] (ImplicitCastExpr, LValueToRValue, LexState *)
  15: MemberExpr 0x561ce746d1e0 <llex.c:461:3, col:7> 'Token':'struct Token' lvalue ->lookahead 0x561ce7426988
`-ImplicitCastExpr 0x561ce746d1c8 <col:3> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x561ce746d1a0 <col:3> 'LexState *' lvalue ParmVar 0x561ce746cfb0 'ls' 'LexState *'
[B1.14]->lookahead
  16: MemberExpr 0x561ce746d218 <llex.c:461:3, col:17> 'int' lvalue .token 0x561ce74253a8
`-MemberExpr 0x561ce746d1e0 <col:3, col:7> 'Token':'struct Token' lvalue ->lookahead 0x561ce7426988
  `-ImplicitCastExpr 0x561ce746d1c8 <col:3> 'LexState *' <LValueToRValue>
    `-DeclRefExpr 0x561ce746d1a0 <col:3> 'LexState *' lvalue ParmVar 0x561ce746cfb0 'ls' 'LexState *'
[B1.15].token
  17: BinaryOperator 0x561ce746d520 <llex.c:461:3, col:56> 'int' '='
|-MemberExpr 0x561ce746d218 <col:3, col:17> 'int' lvalue .token 0x561ce74253a8
| `-MemberExpr 0x561ce746d1e0 <col:3, col:7> 'Token':'struct Token' lvalue ->lookahead 0x561ce7426988
|   `-ImplicitCastExpr 0x561ce746d1c8 <col:3> 'LexState *' <LValueToRValue>
|     `-DeclRefExpr 0x561ce746d1a0 <col:3> 'LexState *' lvalue ParmVar 0x561ce746cfb0 'ls' 'LexState *'
`-CallExpr 0x561ce746d388 <col:25, col:56> 'int'
  |-ImplicitCastExpr 0x561ce746d370 <col:25> 'int (*)(LexState *, SemInfo *)' <FunctionToPointerDecay>
  | `-DeclRefExpr 0x561ce746d250 <col:25> 'int (LexState *, SemInfo *)' Function 0x561ce7461848 'llex' 'int (LexState *, SemInfo *)'
  |-ImplicitCastExpr 0x561ce746d3c0 <col:30> 'LexState *' <LValueToRValue>
  | `-DeclRefExpr 0x561ce746d278 <col:30> 'LexState *' lvalue ParmVar 0x561ce746cfb0 'ls' 'LexState *'
  `-UnaryOperator 0x561ce746d350 <col:34, col:49> 'SemInfo *' prefix '&'
    `-MemberExpr 0x561ce746d318 <col:35, col:49> 'SemInfo':'SemInfo' lvalue .seminfo 0x561ce7425420
      `-MemberExpr 0x561ce746d2e0 <col:35, col:39> 'Token':'struct Token' lvalue ->lookahead 0x561ce7426988
        `-ImplicitCastExpr 0x561ce746d2c8 <col:35> 'LexState *' <LValueToRValue>
          `-DeclRefExpr 0x561ce746d2a0 <col:35> 'LexState *' lvalue ParmVar 0x561ce746cfb0 'ls' 'LexState *'
[B1.16] = [B1.12]
   Preds (1): B2
   Succs (1): B0

 [B0 (EXIT)]
   Preds (1): B1
