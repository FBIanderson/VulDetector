static int statement(LexState *ls)
 [B15 (ENTRY)]
   Succs (1): B1

 [B1]
   1: DeclRefExpr 0x558fa8f424f8 <lparser.c:1272:14> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
   2: ImplicitCastExpr 0x558fa8f42520 <lparser.c:1272:14> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f424f8 <col:14> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B1.1] (ImplicitCastExpr, LValueToRValue, LexState *)
   3: MemberExpr 0x558fa8f42538 <lparser.c:1272:14, col:18> 'int' lvalue ->linenumber 0x558fa8ea0308
`-ImplicitCastExpr 0x558fa8f42520 <col:14> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f424f8 <col:14> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B1.2]->linenumber
   4: ImplicitCastExpr 0x558fa8f42570 <lparser.c:1272:14, col:18> 'int' <LValueToRValue>
`-MemberExpr 0x558fa8f42538 <col:14, col:18> 'int' lvalue ->linenumber 0x558fa8ea0308
  `-ImplicitCastExpr 0x558fa8f42520 <col:14> 'LexState *' <LValueToRValue>
    `-DeclRefExpr 0x558fa8f424f8 <col:14> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B1.3] (ImplicitCastExpr, LValueToRValue, int)
   5: DeclStmt 0x558fa8f42588 <lparser.c:1272:3, col:28>col:7
`-VarDecl 0x558fa8f42498 <col:3, col:18> col:7 used line 'int' cinit
  `-ImplicitCastExpr 0x558fa8f42570 <col:14, col:18> 'int' <LValueToRValue>
    `-MemberExpr 0x558fa8f42538 <col:14, col:18> 'int' lvalue ->linenumber 0x558fa8ea0308
      `-ImplicitCastExpr 0x558fa8f42520 <col:14> 'LexState *' <LValueToRValue>
        `-DeclRefExpr 0x558fa8f424f8 <col:14> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
int line = ls->linenumber;
   6: DeclRefExpr 0x558fa8f425a0 <lparser.c:1273:11> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
   7: ImplicitCastExpr 0x558fa8f425c8 <lparser.c:1273:11> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f425a0 <col:11> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B1.6] (ImplicitCastExpr, LValueToRValue, LexState *)
   8: MemberExpr 0x558fa8f425e0 <lparser.c:1273:11, col:15> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
`-ImplicitCastExpr 0x558fa8f425c8 <col:11> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f425a0 <col:11> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B1.7]->t
   9: MemberExpr 0x558fa8f42618 <lparser.c:1273:11, col:17> 'int' lvalue .token 0x558fa8e9ec88
`-MemberExpr 0x558fa8f425e0 <col:11, col:15> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
  `-ImplicitCastExpr 0x558fa8f425c8 <col:11> 'LexState *' <LValueToRValue>
    `-DeclRefExpr 0x558fa8f425a0 <col:11> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B1.8].token
  10: ImplicitCastExpr 0x558fa8f42650 <lparser.c:1273:11, col:17> 'int' <LValueToRValue>
`-MemberExpr 0x558fa8f42618 <col:11, col:17> 'int' lvalue .token 0x558fa8e9ec88
  `-MemberExpr 0x558fa8f425e0 <col:11, col:15> 'Token':'struct Token' lvalue ->t 0x558fa8ea03e0
    `-ImplicitCastExpr 0x558fa8f425c8 <col:11> 'LexState *' <LValueToRValue>
      `-DeclRefExpr 0x558fa8f425a0 <col:11> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B1.9] (ImplicitCastExpr, LValueToRValue, int)
   T: switch [B1.10]
   Preds (1): B15
   Succs (10): B3 B4 B8 B9 B10 B11 B12 B13
     B14 B2

 [B2]
  default:
   1: DeclRefExpr 0x558fa8f43a10 <lparser.c:1318:7> 'void (LexState *)' Function 0x558fa8f3ea10 'exprstat' 'void (LexState *)'
exprstat
   2: ImplicitCastExpr 0x558fa8f43a60 <lparser.c:1318:7> 'void (*)(LexState *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f43a10 <col:7> 'void (LexState *)' Function 0x558fa8f3ea10 'exprstat' 'void (LexState *)'
[B2.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *))
   3: DeclRefExpr 0x558fa8f43a38 <lparser.c:1318:16> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f43aa8 <lparser.c:1318:16> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f43a38 <col:16> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B2.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: CallExpr 0x558fa8f43a78 <lparser.c:1318:7, col:18> 'void'
|-ImplicitCastExpr 0x558fa8f43a60 <col:7> 'void (*)(LexState *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f43a10 <col:7> 'void (LexState *)' Function 0x558fa8f3ea10 'exprstat' 'void (LexState *)'
`-ImplicitCastExpr 0x558fa8f43aa8 <col:16> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f43a38 <col:16> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B2.2]([B2.4])
   6: IntegerLiteral 0x558fa8f43ac0 <lparser.c:1319:14> 'int' 0
0
   7: ReturnStmt 0x558fa8f43ae0 <lparser.c:1319:7, col:14>
`-IntegerLiteral 0x558fa8f43ac0 <col:14> 'int' 0
return [B2.6];
   Preds (1): B1
   Succs (1): B0

 [B3]
  case TK_BREAK:
   1: DeclRefExpr 0x558fa8f43850 <lparser.c:1313:7> 'void (LexState *)' Function 0x558fa8ea1430 'luaX_next' 'void (LexState *)'
luaX_next
   2: ImplicitCastExpr 0x558fa8f438a0 <lparser.c:1313:7> 'void (*)(LexState *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f43850 <col:7> 'void (LexState *)' Function 0x558fa8ea1430 'luaX_next' 'void (LexState *)'
[B3.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *))
   3: DeclRefExpr 0x558fa8f43878 <lparser.c:1313:17> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f438e8 <lparser.c:1313:17> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f43878 <col:17> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B3.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: CallExpr 0x558fa8f438b8 <lparser.c:1313:7, col:19> 'void'
|-ImplicitCastExpr 0x558fa8f438a0 <col:7> 'void (*)(LexState *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f43850 <col:7> 'void (LexState *)' Function 0x558fa8ea1430 'luaX_next' 'void (LexState *)'
`-ImplicitCastExpr 0x558fa8f438e8 <col:17> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f43878 <col:17> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B3.2]([B3.4])
   6: DeclRefExpr 0x558fa8f43900 <lparser.c:1314:7> 'void (LexState *)' Function 0x558fa8f2f820 'breakstat' 'void (LexState *)'
breakstat
   7: ImplicitCastExpr 0x558fa8f43950 <lparser.c:1314:7> 'void (*)(LexState *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f43900 <col:7> 'void (LexState *)' Function 0x558fa8f2f820 'breakstat' 'void (LexState *)'
[B3.6] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *))
   8: DeclRefExpr 0x558fa8f43928 <lparser.c:1314:17> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
   9: ImplicitCastExpr 0x558fa8f43998 <lparser.c:1314:17> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f43928 <col:17> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B3.8] (ImplicitCastExpr, LValueToRValue, LexState *)
  10: CallExpr 0x558fa8f43968 <lparser.c:1314:7, col:19> 'void'
|-ImplicitCastExpr 0x558fa8f43950 <col:7> 'void (*)(LexState *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f43900 <col:7> 'void (LexState *)' Function 0x558fa8f2f820 'breakstat' 'void (LexState *)'
`-ImplicitCastExpr 0x558fa8f43998 <col:17> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f43928 <col:17> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B3.7]([B3.9])
  11: IntegerLiteral 0x558fa8f439b0 <lparser.c:1315:14> 'int' 1
1
  12: ReturnStmt 0x558fa8f439d0 <lparser.c:1315:7, col:14>
`-IntegerLiteral 0x558fa8f439b0 <col:14> 'int' 1
return [B3.11];
   Preds (1): B1
   Succs (1): B0

 [B4]
  case TK_RETURN:
   1: DeclRefExpr 0x558fa8f436e8 <lparser.c:1309:7> 'void (LexState *)' Function 0x558fa8f40030 'retstat' 'void (LexState *)'
retstat
   2: ImplicitCastExpr 0x558fa8f43738 <lparser.c:1309:7> 'void (*)(LexState *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f436e8 <col:7> 'void (LexState *)' Function 0x558fa8f40030 'retstat' 'void (LexState *)'
[B4.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *))
   3: DeclRefExpr 0x558fa8f43710 <lparser.c:1309:15> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f43780 <lparser.c:1309:15> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f43710 <col:15> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B4.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: CallExpr 0x558fa8f43750 <lparser.c:1309:7, col:17> 'void'
|-ImplicitCastExpr 0x558fa8f43738 <col:7> 'void (*)(LexState *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f436e8 <col:7> 'void (LexState *)' Function 0x558fa8f40030 'retstat' 'void (LexState *)'
`-ImplicitCastExpr 0x558fa8f43780 <col:15> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f43710 <col:15> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B4.2]([B4.4])
   6: IntegerLiteral 0x558fa8f43798 <lparser.c:1310:14> 'int' 1
1
   7: ReturnStmt 0x558fa8f437b8 <lparser.c:1310:7, col:14>
`-IntegerLiteral 0x558fa8f43798 <col:14> 'int' 1
return [B4.6];
   Preds (1): B1
   Succs (1): B0

 [B5]
   1: IntegerLiteral 0x558fa8f43628 <lparser.c:1306:14> 'int' 0
0
   2: ReturnStmt 0x558fa8f43648 <lparser.c:1306:7, col:14>
`-IntegerLiteral 0x558fa8f43628 <col:14> 'int' 0
return [B5.1];
   Preds (2): B6 B7
   Succs (1): B0

 [B6]
   1: DeclRefExpr 0x558fa8f43540 <lparser.c:1305:9> 'void (LexState *)' Function 0x558fa8f3caa0 'localstat' 'void (LexState *)'
localstat
   2: ImplicitCastExpr 0x558fa8f43590 <lparser.c:1305:9> 'void (*)(LexState *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f43540 <col:9> 'void (LexState *)' Function 0x558fa8f3caa0 'localstat' 'void (LexState *)'
[B6.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *))
   3: DeclRefExpr 0x558fa8f43568 <lparser.c:1305:19> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f435d8 <lparser.c:1305:19> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f43568 <col:19> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B6.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: CallExpr 0x558fa8f435a8 <lparser.c:1305:9, col:21> 'void'
|-ImplicitCastExpr 0x558fa8f43590 <col:9> 'void (*)(LexState *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f43540 <col:9> 'void (LexState *)' Function 0x558fa8f3caa0 'localstat' 'void (LexState *)'
`-ImplicitCastExpr 0x558fa8f435d8 <col:19> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f43568 <col:19> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B6.2]([B6.4])
   Preds (1): B8
   Succs (1): B5

 [B7]
   1: DeclRefExpr 0x558fa8f43490 <lparser.c:1303:9> 'void (LexState *)' Function 0x558fa8f3bac8 'localfunc' 'void (LexState *)'
localfunc
   2: ImplicitCastExpr 0x558fa8f434e0 <lparser.c:1303:9> 'void (*)(LexState *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f43490 <col:9> 'void (LexState *)' Function 0x558fa8f3bac8 'localfunc' 'void (LexState *)'
[B7.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *))
   3: DeclRefExpr 0x558fa8f434b8 <lparser.c:1303:19> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f43528 <lparser.c:1303:19> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f434b8 <col:19> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B7.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: CallExpr 0x558fa8f434f8 <lparser.c:1303:9, col:21> 'void'
|-ImplicitCastExpr 0x558fa8f434e0 <col:9> 'void (*)(LexState *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f43490 <col:9> 'void (LexState *)' Function 0x558fa8f3bac8 'localfunc' 'void (LexState *)'
`-ImplicitCastExpr 0x558fa8f43528 <col:19> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f434b8 <col:19> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B7.2]([B7.4])
   Preds (1): B8
   Succs (1): B5

 [B8]
  case TK_LOCAL:
   1: DeclRefExpr 0x558fa8f43300 <lparser.c:1301:7> 'void (LexState *)' Function 0x558fa8ea1430 'luaX_next' 'void (LexState *)'
luaX_next
   2: ImplicitCastExpr 0x558fa8f43350 <lparser.c:1301:7> 'void (*)(LexState *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f43300 <col:7> 'void (LexState *)' Function 0x558fa8ea1430 'luaX_next' 'void (LexState *)'
[B8.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *))
   3: DeclRefExpr 0x558fa8f43328 <lparser.c:1301:17> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f43398 <lparser.c:1301:17> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f43328 <col:17> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B8.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: CallExpr 0x558fa8f43368 <lparser.c:1301:7, col:19> 'void'
|-ImplicitCastExpr 0x558fa8f43350 <col:7> 'void (*)(LexState *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f43300 <col:7> 'void (LexState *)' Function 0x558fa8ea1430 'luaX_next' 'void (LexState *)'
`-ImplicitCastExpr 0x558fa8f43398 <col:17> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f43328 <col:17> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B8.2]([B8.4])
   6: DeclRefExpr 0x558fa8f433b0 <lparser.c:1302:11> 'int (LexState *, int)' Function 0x558fa8eed328 'testnext' 'int (LexState *, int)'
testnext
   7: ImplicitCastExpr 0x558fa8f43428 <lparser.c:1302:11> 'int (*)(LexState *, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f433b0 <col:11> 'int (LexState *, int)' Function 0x558fa8eed328 'testnext' 'int (LexState *, int)'
[B8.6] (ImplicitCastExpr, FunctionToPointerDecay, int (*)(LexState *, int))
   8: DeclRefExpr 0x558fa8f433d8 <lparser.c:1302:20> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
   9: ImplicitCastExpr 0x558fa8f43478 <lparser.c:1302:20> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f433d8 <col:20> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B8.8] (ImplicitCastExpr, LValueToRValue, LexState *)
  10: DeclRefExpr 0x558fa8f43400 <lparser.c:1302:24> 'int' EnumConstant 0x558fa8e9e1d0 'TK_FUNCTION' 'int'
TK_FUNCTION
  11: CallExpr 0x558fa8f43440 <lparser.c:1302:11, col:35> 'int'
|-ImplicitCastExpr 0x558fa8f43428 <col:11> 'int (*)(LexState *, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f433b0 <col:11> 'int (LexState *, int)' Function 0x558fa8eed328 'testnext' 'int (LexState *, int)'
|-ImplicitCastExpr 0x558fa8f43478 <col:20> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f433d8 <col:20> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
`-DeclRefExpr 0x558fa8f43400 <col:24> 'int' EnumConstant 0x558fa8e9e1d0 'TK_FUNCTION' 'int'
[B8.7]([B8.9], [B8.10])
   T: if [B8.11]
   Preds (1): B1
   Succs (2): B7 B6

 [B9]
  case TK_FUNCTION:
   1: DeclRefExpr 0x558fa8f43150 <lparser.c:1297:7> 'void (LexState *, int)' Function 0x558fa8f3e050 'funcstat' 'void (LexState *, int)'
funcstat
   2: ImplicitCastExpr 0x558fa8f431c8 <lparser.c:1297:7> 'void (*)(LexState *, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f43150 <col:7> 'void (LexState *, int)' Function 0x558fa8f3e050 'funcstat' 'void (LexState *, int)'
[B9.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *, int))
   3: DeclRefExpr 0x558fa8f43178 <lparser.c:1297:16> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f43218 <lparser.c:1297:16> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f43178 <col:16> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B9.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: DeclRefExpr 0x558fa8f431a0 <lparser.c:1297:20> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
line
   6: ImplicitCastExpr 0x558fa8f43230 <lparser.c:1297:20> 'int' <LValueToRValue>
`-DeclRefExpr 0x558fa8f431a0 <col:20> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
[B9.5] (ImplicitCastExpr, LValueToRValue, int)
   7: CallExpr 0x558fa8f431e0 <lparser.c:1297:7, col:24> 'void'
|-ImplicitCastExpr 0x558fa8f431c8 <col:7> 'void (*)(LexState *, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f43150 <col:7> 'void (LexState *, int)' Function 0x558fa8f3e050 'funcstat' 'void (LexState *, int)'
|-ImplicitCastExpr 0x558fa8f43218 <col:16> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f43178 <col:16> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
`-ImplicitCastExpr 0x558fa8f43230 <col:20> 'int' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f431a0 <col:20> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
[B9.2]([B9.4], [B9.6])
   8: IntegerLiteral 0x558fa8f43248 <lparser.c:1298:14> 'int' 0
0
   9: ReturnStmt 0x558fa8f43268 <lparser.c:1298:7, col:14>
`-IntegerLiteral 0x558fa8f43248 <col:14> 'int' 0
return [B9.8];
   Preds (1): B1
   Succs (1): B0

 [B10]
  case TK_REPEAT:
   1: DeclRefExpr 0x558fa8f42fa0 <lparser.c:1293:7> 'void (LexState *, int)' Function 0x558fa8f316d8 'repeatstat' 'void (LexState *, int)'
repeatstat
   2: ImplicitCastExpr 0x558fa8f43018 <lparser.c:1293:7> 'void (*)(LexState *, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f42fa0 <col:7> 'void (LexState *, int)' Function 0x558fa8f316d8 'repeatstat' 'void (LexState *, int)'
[B10.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *, int))
   3: DeclRefExpr 0x558fa8f42fc8 <lparser.c:1293:18> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f43068 <lparser.c:1293:18> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f42fc8 <col:18> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B10.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: DeclRefExpr 0x558fa8f42ff0 <lparser.c:1293:22> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
line
   6: ImplicitCastExpr 0x558fa8f43080 <lparser.c:1293:22> 'int' <LValueToRValue>
`-DeclRefExpr 0x558fa8f42ff0 <col:22> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
[B10.5] (ImplicitCastExpr, LValueToRValue, int)
   7: CallExpr 0x558fa8f43030 <lparser.c:1293:7, col:26> 'void'
|-ImplicitCastExpr 0x558fa8f43018 <col:7> 'void (*)(LexState *, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f42fa0 <col:7> 'void (LexState *, int)' Function 0x558fa8f316d8 'repeatstat' 'void (LexState *, int)'
|-ImplicitCastExpr 0x558fa8f43068 <col:18> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f42fc8 <col:18> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
`-ImplicitCastExpr 0x558fa8f43080 <col:22> 'int' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f42ff0 <col:22> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
[B10.2]([B10.4], [B10.6])
   8: IntegerLiteral 0x558fa8f43098 <lparser.c:1294:14> 'int' 0
0
   9: ReturnStmt 0x558fa8f430b8 <lparser.c:1294:7, col:14>
`-IntegerLiteral 0x558fa8f43098 <col:14> 'int' 0
return [B10.8];
   Preds (1): B1
   Succs (1): B0

 [B11]
  case TK_FOR:
   1: DeclRefExpr 0x558fa8f42df0 <lparser.c:1289:7> 'void (LexState *, int)' Function 0x558fa8f391d8 'forstat' 'void (LexState *, int)'
forstat
   2: ImplicitCastExpr 0x558fa8f42e68 <lparser.c:1289:7> 'void (*)(LexState *, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f42df0 <col:7> 'void (LexState *, int)' Function 0x558fa8f391d8 'forstat' 'void (LexState *, int)'
[B11.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *, int))
   3: DeclRefExpr 0x558fa8f42e18 <lparser.c:1289:15> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f42eb8 <lparser.c:1289:15> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f42e18 <col:15> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B11.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: DeclRefExpr 0x558fa8f42e40 <lparser.c:1289:19> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
line
   6: ImplicitCastExpr 0x558fa8f42ed0 <lparser.c:1289:19> 'int' <LValueToRValue>
`-DeclRefExpr 0x558fa8f42e40 <col:19> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
[B11.5] (ImplicitCastExpr, LValueToRValue, int)
   7: CallExpr 0x558fa8f42e80 <lparser.c:1289:7, col:23> 'void'
|-ImplicitCastExpr 0x558fa8f42e68 <col:7> 'void (*)(LexState *, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f42df0 <col:7> 'void (LexState *, int)' Function 0x558fa8f391d8 'forstat' 'void (LexState *, int)'
|-ImplicitCastExpr 0x558fa8f42eb8 <col:15> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f42e18 <col:15> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
`-ImplicitCastExpr 0x558fa8f42ed0 <col:19> 'int' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f42e40 <col:19> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
[B11.2]([B11.4], [B11.6])
   8: IntegerLiteral 0x558fa8f42ee8 <lparser.c:1290:14> 'int' 0
0
   9: ReturnStmt 0x558fa8f42f08 <lparser.c:1290:7, col:14>
`-IntegerLiteral 0x558fa8f42ee8 <col:14> 'int' 0
return [B11.8];
   Preds (1): B1
   Succs (1): B0

 [B12]
  case TK_DO:
   1: DeclRefExpr 0x558fa8f42a70 <lparser.c:1283:7> 'void (LexState *)' Function 0x558fa8ea1430 'luaX_next' 'void (LexState *)'
luaX_next
   2: ImplicitCastExpr 0x558fa8f42ac0 <lparser.c:1283:7> 'void (*)(LexState *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f42a70 <col:7> 'void (LexState *)' Function 0x558fa8ea1430 'luaX_next' 'void (LexState *)'
[B12.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *))
   3: DeclRefExpr 0x558fa8f42a98 <lparser.c:1283:17> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f42b08 <lparser.c:1283:17> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f42a98 <col:17> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B12.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: CallExpr 0x558fa8f42ad8 <lparser.c:1283:7, col:19> 'void'
|-ImplicitCastExpr 0x558fa8f42ac0 <col:7> 'void (*)(LexState *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f42a70 <col:7> 'void (LexState *)' Function 0x558fa8ea1430 'luaX_next' 'void (LexState *)'
`-ImplicitCastExpr 0x558fa8f42b08 <col:17> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f42a98 <col:17> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B12.2]([B12.4])
   6: DeclRefExpr 0x558fa8f42b20 <lparser.c:1284:7> 'void (LexState *)' Function 0x558fa8f2a638 'block' 'void (LexState *)'
block
   7: ImplicitCastExpr 0x558fa8f42b70 <lparser.c:1284:7> 'void (*)(LexState *)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f42b20 <col:7> 'void (LexState *)' Function 0x558fa8f2a638 'block' 'void (LexState *)'
[B12.6] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *))
   8: DeclRefExpr 0x558fa8f42b48 <lparser.c:1284:13> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
   9: ImplicitCastExpr 0x558fa8f42bb8 <lparser.c:1284:13> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f42b48 <col:13> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B12.8] (ImplicitCastExpr, LValueToRValue, LexState *)
  10: CallExpr 0x558fa8f42b88 <lparser.c:1284:7, col:15> 'void'
|-ImplicitCastExpr 0x558fa8f42b70 <col:7> 'void (*)(LexState *)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f42b20 <col:7> 'void (LexState *)' Function 0x558fa8f2a638 'block' 'void (LexState *)'
`-ImplicitCastExpr 0x558fa8f42bb8 <col:13> 'LexState *' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f42b48 <col:13> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B12.7]([B12.9])
  11: DeclRefExpr 0x558fa8f42bd0 <lparser.c:1285:7> 'void (LexState *, int, int, int)' Function 0x558fa8eee1e0 'check_match' 'void (LexState *, int, int, int)'
check_match
  12: ImplicitCastExpr 0x558fa8f42c98 <lparser.c:1285:7> 'void (*)(LexState *, int, int, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f42bd0 <col:7> 'void (LexState *, int, int, int)' Function 0x558fa8eee1e0 'check_match' 'void (LexState *, int, int, int)'
[B12.11] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *, int, int, int))
  13: DeclRefExpr 0x558fa8f42bf8 <lparser.c:1285:19> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
  14: ImplicitCastExpr 0x558fa8f42cf8 <lparser.c:1285:19> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f42bf8 <col:19> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B12.13] (ImplicitCastExpr, LValueToRValue, LexState *)
  15: DeclRefExpr 0x558fa8f42c20 <lparser.c:1285:23> 'int' EnumConstant 0x558fa8e9e0f8 'TK_END' 'int'
TK_END
  16: DeclRefExpr 0x558fa8f42c48 <lparser.c:1285:31> 'int' EnumConstant 0x558fa8e9e020 'TK_DO' 'int'
TK_DO
  17: DeclRefExpr 0x558fa8f42c70 <lparser.c:1285:38> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
line
  18: ImplicitCastExpr 0x558fa8f42d10 <lparser.c:1285:38> 'int' <LValueToRValue>
`-DeclRefExpr 0x558fa8f42c70 <col:38> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
[B12.17] (ImplicitCastExpr, LValueToRValue, int)
  19: CallExpr 0x558fa8f42cb0 <lparser.c:1285:7, col:42> 'void'
|-ImplicitCastExpr 0x558fa8f42c98 <col:7> 'void (*)(LexState *, int, int, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f42bd0 <col:7> 'void (LexState *, int, int, int)' Function 0x558fa8eee1e0 'check_match' 'void (LexState *, int, int, int)'
|-ImplicitCastExpr 0x558fa8f42cf8 <col:19> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f42bf8 <col:19> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
|-DeclRefExpr 0x558fa8f42c20 <col:23> 'int' EnumConstant 0x558fa8e9e0f8 'TK_END' 'int'
|-DeclRefExpr 0x558fa8f42c48 <col:31> 'int' EnumConstant 0x558fa8e9e020 'TK_DO' 'int'
`-ImplicitCastExpr 0x558fa8f42d10 <col:38> 'int' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f42c70 <col:38> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
[B12.12]([B12.14], [B12.15], [B12.16], [B12.18])
  20: IntegerLiteral 0x558fa8f42d28 <lparser.c:1286:14> 'int' 0
0
  21: ReturnStmt 0x558fa8f42d48 <lparser.c:1286:7, col:14>
`-IntegerLiteral 0x558fa8f42d28 <col:14> 'int' 0
return [B12.20];
   Preds (1): B1
   Succs (1): B0

 [B13]
  case TK_WHILE:
   1: DeclRefExpr 0x558fa8f428a8 <lparser.c:1279:7> 'void (LexState *, int)' Function 0x558fa8f30748 'whilestat' 'void (LexState *, int)'
whilestat
   2: ImplicitCastExpr 0x558fa8f42920 <lparser.c:1279:7> 'void (*)(LexState *, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f428a8 <col:7> 'void (LexState *, int)' Function 0x558fa8f30748 'whilestat' 'void (LexState *, int)'
[B13.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *, int))
   3: DeclRefExpr 0x558fa8f428d0 <lparser.c:1279:17> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f42988 <lparser.c:1279:17> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f428d0 <col:17> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B13.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: DeclRefExpr 0x558fa8f428f8 <lparser.c:1279:21> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
line
   6: ImplicitCastExpr 0x558fa8f429a0 <lparser.c:1279:21> 'int' <LValueToRValue>
`-DeclRefExpr 0x558fa8f428f8 <col:21> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
[B13.5] (ImplicitCastExpr, LValueToRValue, int)
   7: CallExpr 0x558fa8f42950 <lparser.c:1279:7, col:25> 'void'
|-ImplicitCastExpr 0x558fa8f42920 <col:7> 'void (*)(LexState *, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f428a8 <col:7> 'void (LexState *, int)' Function 0x558fa8f30748 'whilestat' 'void (LexState *, int)'
|-ImplicitCastExpr 0x558fa8f42988 <col:17> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f428d0 <col:17> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
`-ImplicitCastExpr 0x558fa8f429a0 <col:21> 'int' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f428f8 <col:21> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
[B13.2]([B13.4], [B13.6])
   8: IntegerLiteral 0x558fa8f429b8 <lparser.c:1280:14> 'int' 0
0
   9: ReturnStmt 0x558fa8f429d8 <lparser.c:1280:7, col:14>
`-IntegerLiteral 0x558fa8f429b8 <col:14> 'int' 0
return [B13.8];
   Preds (1): B1
   Succs (1): B0

 [B14]
  case TK_IF:
   1: DeclRefExpr 0x558fa8f426f8 <lparser.c:1275:7> 'void (LexState *, int)' Function 0x558fa8f3a740 'ifstat' 'void (LexState *, int)'
ifstat
   2: ImplicitCastExpr 0x558fa8f42770 <lparser.c:1275:7> 'void (*)(LexState *, int)' <FunctionToPointerDecay>
`-DeclRefExpr 0x558fa8f426f8 <col:7> 'void (LexState *, int)' Function 0x558fa8f3a740 'ifstat' 'void (LexState *, int)'
[B14.1] (ImplicitCastExpr, FunctionToPointerDecay, void (*)(LexState *, int))
   3: DeclRefExpr 0x558fa8f42720 <lparser.c:1275:14> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
ls
   4: ImplicitCastExpr 0x558fa8f427c0 <lparser.c:1275:14> 'LexState *' <LValueToRValue>
`-DeclRefExpr 0x558fa8f42720 <col:14> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
[B14.3] (ImplicitCastExpr, LValueToRValue, LexState *)
   5: DeclRefExpr 0x558fa8f42748 <lparser.c:1275:18> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
line
   6: ImplicitCastExpr 0x558fa8f427d8 <lparser.c:1275:18> 'int' <LValueToRValue>
`-DeclRefExpr 0x558fa8f42748 <col:18> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
[B14.5] (ImplicitCastExpr, LValueToRValue, int)
   7: CallExpr 0x558fa8f42788 <lparser.c:1275:7, col:22> 'void'
|-ImplicitCastExpr 0x558fa8f42770 <col:7> 'void (*)(LexState *, int)' <FunctionToPointerDecay>
| `-DeclRefExpr 0x558fa8f426f8 <col:7> 'void (LexState *, int)' Function 0x558fa8f3a740 'ifstat' 'void (LexState *, int)'
|-ImplicitCastExpr 0x558fa8f427c0 <col:14> 'LexState *' <LValueToRValue>
| `-DeclRefExpr 0x558fa8f42720 <col:14> 'LexState *' lvalue ParmVar 0x558fa8f42348 'ls' 'LexState *'
`-ImplicitCastExpr 0x558fa8f427d8 <col:18> 'int' <LValueToRValue>
  `-DeclRefExpr 0x558fa8f42748 <col:18> 'int' lvalue Var 0x558fa8f42498 'line' 'int'
[B14.2]([B14.4], [B14.6])
   8: IntegerLiteral 0x558fa8f427f0 <lparser.c:1276:14> 'int' 0
0
   9: ReturnStmt 0x558fa8f42810 <lparser.c:1276:7, col:14>
`-IntegerLiteral 0x558fa8f427f0 <col:14> 'int' 0
return [B14.8];
   Preds (1): B1
   Succs (1): B0

 [B0 (EXIT)]
   Preds (10): B2 B3 B4 B5 B9 B10 B11 B12
      B13 B14
